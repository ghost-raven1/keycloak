import {
  require_react_dom
} from "./chunk-KX5CDAJP.js";
import {
  __rest,
  caret_down_icon_default,
  check_circle_icon_default,
  check_icon_default,
  ellipsis_v_icon_default,
  exclamation_circle_icon_default,
  exclamation_triangle_icon_default,
  star_icon_default,
  times_circle_icon_default,
  times_icon_default
} from "./chunk-T6XLOOLQ.js";
import {
  require_react
} from "./chunk-F6MCTWDU.js";
import {
  css
} from "./chunk-2RPZLTUH.js";
import {
  __toESM
} from "./chunk-BQWMX7FD.js";

// ../../node_modules/.pnpm/@patternfly+react-tokens@4.94.7/node_modules/@patternfly/react-tokens/dist/esm/global_breakpoint_sm.js
var global_breakpoint_sm = {
  "name": "--pf-global--breakpoint--sm",
  "value": "576px",
  "var": "var(--pf-global--breakpoint--sm)"
};
var global_breakpoint_sm_default = global_breakpoint_sm;

// ../../node_modules/.pnpm/@patternfly+react-tokens@4.94.7/node_modules/@patternfly/react-tokens/dist/esm/global_breakpoint_md.js
var global_breakpoint_md = {
  "name": "--pf-global--breakpoint--md",
  "value": "768px",
  "var": "var(--pf-global--breakpoint--md)"
};
var global_breakpoint_md_default = global_breakpoint_md;

// ../../node_modules/.pnpm/@patternfly+react-tokens@4.94.7/node_modules/@patternfly/react-tokens/dist/esm/global_breakpoint_lg.js
var global_breakpoint_lg = {
  "name": "--pf-global--breakpoint--lg",
  "value": "992px",
  "var": "var(--pf-global--breakpoint--lg)"
};
var global_breakpoint_lg_default = global_breakpoint_lg;

// ../../node_modules/.pnpm/@patternfly+react-tokens@4.94.7/node_modules/@patternfly/react-tokens/dist/esm/global_breakpoint_xl.js
var global_breakpoint_xl = {
  "name": "--pf-global--breakpoint--xl",
  "value": "1200px",
  "var": "var(--pf-global--breakpoint--xl)"
};
var global_breakpoint_xl_default = global_breakpoint_xl;

// ../../node_modules/.pnpm/@patternfly+react-tokens@4.94.7/node_modules/@patternfly/react-tokens/dist/esm/global_breakpoint_2xl.js
var global_breakpoint_2xl = {
  "name": "--pf-global--breakpoint--2xl",
  "value": "1450px",
  "var": "var(--pf-global--breakpoint--2xl)"
};
var global_breakpoint_2xl_default = global_breakpoint_2xl;

// ../../node_modules/.pnpm/@patternfly+react-tokens@4.94.7/node_modules/@patternfly/react-tokens/dist/esm/global_height_breakpoint_sm.js
var global_height_breakpoint_sm = {
  "name": "--pf-global--height-breakpoint--sm",
  "value": "0",
  "var": "var(--pf-global--height-breakpoint--sm)"
};
var global_height_breakpoint_sm_default = global_height_breakpoint_sm;

// ../../node_modules/.pnpm/@patternfly+react-tokens@4.94.7/node_modules/@patternfly/react-tokens/dist/esm/global_height_breakpoint_md.js
var global_height_breakpoint_md = {
  "name": "--pf-global--height-breakpoint--md",
  "value": "40rem",
  "var": "var(--pf-global--height-breakpoint--md)"
};
var global_height_breakpoint_md_default = global_height_breakpoint_md;

// ../../node_modules/.pnpm/@patternfly+react-tokens@4.94.7/node_modules/@patternfly/react-tokens/dist/esm/global_height_breakpoint_lg.js
var global_height_breakpoint_lg = {
  "name": "--pf-global--height-breakpoint--lg",
  "value": "48rem",
  "var": "var(--pf-global--height-breakpoint--lg)"
};
var global_height_breakpoint_lg_default = global_height_breakpoint_lg;

// ../../node_modules/.pnpm/@patternfly+react-tokens@4.94.7/node_modules/@patternfly/react-tokens/dist/esm/global_height_breakpoint_xl.js
var global_height_breakpoint_xl = {
  "name": "--pf-global--height-breakpoint--xl",
  "value": "60rem",
  "var": "var(--pf-global--height-breakpoint--xl)"
};
var global_height_breakpoint_xl_default = global_height_breakpoint_xl;

// ../../node_modules/.pnpm/@patternfly+react-tokens@4.94.7/node_modules/@patternfly/react-tokens/dist/esm/global_height_breakpoint_2xl.js
var global_height_breakpoint_2xl = {
  "name": "--pf-global--height-breakpoint--2xl",
  "value": "80rem",
  "var": "var(--pf-global--height-breakpoint--2xl)"
};
var global_height_breakpoint_2xl_default = global_height_breakpoint_2xl;

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/constants.js
var KEY_CODES = { ARROW_UP: 38, ARROW_DOWN: 40, ESCAPE_KEY: 27, TAB: 9, ENTER: 13, SPACE: 32 };
var SIDE = { RIGHT: "right", LEFT: "left", BOTH: "both", NONE: "none" };
var KEYHANDLER_DIRECTION = { UP: "up", DOWN: "down", RIGHT: "right", LEFT: "left" };
var ValidatedOptions;
(function(ValidatedOptions2) {
  ValidatedOptions2["success"] = "success";
  ValidatedOptions2["error"] = "error";
  ValidatedOptions2["warning"] = "warning";
  ValidatedOptions2["default"] = "default";
})(ValidatedOptions || (ValidatedOptions = {}));
var KeyTypes = {
  Tab: "Tab",
  Space: " ",
  Escape: "Escape",
  Enter: "Enter",
  ArrowUp: "ArrowUp",
  ArrowDown: "ArrowDown",
  ArrowLeft: "ArrowLeft",
  ArrowRight: "ArrowRight"
};
var globalWidthBreakpoints = {
  sm: parseInt(global_breakpoint_sm_default.value),
  md: parseInt(global_breakpoint_md_default.value),
  lg: parseInt(global_breakpoint_lg_default.value),
  xl: parseInt(global_breakpoint_xl_default.value),
  "2xl": parseInt(global_breakpoint_2xl_default.value)
};
var globalHeightBreakpoints = {
  sm: parseInt(global_height_breakpoint_sm_default.value),
  md: parseInt(global_height_breakpoint_md_default.value),
  lg: parseInt(global_height_breakpoint_lg_default.value),
  xl: parseInt(global_height_breakpoint_xl_default.value),
  "2xl": parseInt(global_height_breakpoint_2xl_default.value)
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/FocusTrap/FocusTrap.js
var React = __toESM(require_react());

// ../../node_modules/.pnpm/tabbable@5.3.3/node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  return element.getRootNode();
} : function(element) {
  return element.ownerDocument;
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scope: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex2(node, isScope) {
  if (node.tabIndex < 0) {
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  var nodeRootHost = getRootNode(node).host;
  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
  if (!displayCheck || displayCheck === "full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (nodeIsAttached) {
      return !node.getClientRects().length;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scope;
    var element = isScope ? item.scope : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};

// ../../node_modules/.pnpm/focus-trap@6.9.2/node_modules/focus-trap/dist/focus-trap.esm.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var activeFocusTraps = function() {
  var trapQueue = [];
  return {
    activateTrap: function activateTrap(trap) {
      if (trapQueue.length > 0) {
        var activeTrap = trapQueue[trapQueue.length - 1];
        if (activeTrap !== trap) {
          activeTrap.pause();
        }
      }
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex === -1) {
        trapQueue.push(trap);
      } else {
        trapQueue.splice(trapIndex, 1);
        trapQueue.push(trap);
      }
    },
    deactivateTrap: function deactivateTrap(trap) {
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex !== -1) {
        trapQueue.splice(trapIndex, 1);
      }
      if (trapQueue.length > 0) {
        trapQueue[trapQueue.length - 1].unpause();
      }
    }
  };
}();
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e) {
  return e.key === "Escape" || e.key === "Esc" || e.keyCode === 27;
};
var isTabEvent = function isTabEvent2(e) {
  return e.key === "Tab" || e.keyCode === 9;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var findIndex = function findIndex2(arr, fn) {
  var idx = -1;
  arr.every(function(value, i) {
    if (fn(value)) {
      idx = i;
      return false;
    }
    return true;
  });
  return idx;
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   firstTabbableNode: HTMLElement|null,
    //   lastTabbableNode: HTMLElement|null,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element) {
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus");
    if (node === false) {
      return false;
    }
    if (node === void 0) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      return {
        container,
        tabbableNodes,
        focusableNodes,
        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = focusableNodes.findIndex(function(n) {
            return n === node;
          });
          if (nodeIdx < 0) {
            return void 0;
          }
          if (forward) {
            return focusableNodes.slice(nodeIdx + 1).find(function(n) {
              return isTabbable(n, config.tabbableOptions);
            });
          }
          return focusableNodes.slice(0, nodeIdx).reverse().find(function(n) {
            return isTabbable(n, config.tabbableOptions);
          });
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
  };
  var tryFocus = function tryFocus2(node) {
    if (node === false) {
      return;
    }
    if (node === doc.activeElement) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus2(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };
  var checkPointerDown = function checkPointerDown2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      trap.deactivate({
        // if, on deactivation, we should return focus to the node originally-focused
        //  when the trap was activated (or the configured `setReturnFocus` node),
        //  then assume it's also OK to return focus to the outside node that was
        //  just clicked, causing deactivation, as long as that node is focusable;
        //  if it isn't focusable, then return focus to the original node focused
        //  on activation (or the configured `setReturnFocus` node)
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked, whether it's focusable or not; by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node)
        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(e) {
    var target = getActualTarget(e);
    var targetContained = findContainerIndex(target) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      e.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }
  };
  var checkTab = function checkTab2(e) {
    var target = getActualTarget(e);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (e.shiftKey) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (e.shiftKey) {
        var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
          var firstTabbableNode = _ref2.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = destinationGroup.lastTabbableNode;
        }
      } else {
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
          var lastTabbableNode = _ref3.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = _destinationGroup.firstTabbableNode;
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    if (destinationNode) {
      e.preventDefault();
      tryFocus(destinationNode);
    }
  };
  var checkKey = function checkKey2(e) {
    if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates, e) !== false) {
      e.preventDefault();
      trap.deactivate();
      return;
    }
    if (isTabEvent(e)) {
      checkTab(e);
      return;
    }
  };
  var checkClick = function checkClick2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trap);
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkKey, true);
    return trap;
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      if (onActivate) {
        onActivate();
      }
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        if (onPostActivate) {
          onPostActivate();
        }
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      activeFocusTraps.deactivateTrap(trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      if (onDeactivate) {
        onDeactivate();
      }
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          if (onPostDeactivate) {
            onPostDeactivate();
          }
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause() {
      if (state.paused || !state.active) {
        return this;
      }
      state.paused = true;
      removeListeners();
      return this;
    },
    unpause: function unpause() {
      if (!state.paused || !state.active) {
        return this;
      }
      state.paused = false;
      updateTabbableNodes();
      addListeners();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      return this;
    }
  };
  trap.updateContainerElements(elements);
  return trap;
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/FocusTrap/FocusTrap.js
var FocusTrapBase = class extends React.Component {
  constructor(props) {
    super(props);
    this.divRef = this.props.innerRef || React.createRef();
    if (typeof document !== "undefined") {
      this.previouslyFocusedElement = document.activeElement;
    }
  }
  componentDidMount() {
    this.focusTrap = createFocusTrap(this.divRef.current, Object.assign(Object.assign({}, this.props.focusTrapOptions), { returnFocusOnDeactivate: false }));
    if (this.props.active) {
      this.focusTrap.activate();
    }
    if (this.props.paused) {
      this.focusTrap.pause();
    }
  }
  componentDidUpdate(prevProps) {
    if (prevProps.active && !this.props.active) {
      this.focusTrap.deactivate();
    } else if (!prevProps.active && this.props.active) {
      this.focusTrap.activate();
    }
    if (prevProps.paused && !this.props.paused) {
      this.focusTrap.unpause();
    } else if (!prevProps.paused && this.props.paused) {
      this.focusTrap.pause();
    }
  }
  componentWillUnmount() {
    this.focusTrap.deactivate();
    if (this.props.focusTrapOptions.returnFocusOnDeactivate !== false && this.previouslyFocusedElement && this.previouslyFocusedElement.focus) {
      this.previouslyFocusedElement.focus({ preventScroll: this.props.preventScrollOnDeactivate });
    }
  }
  render() {
    const _a = this.props, {
      children,
      className,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      focusTrapOptions,
      active,
      paused,
      preventScrollOnDeactivate,
      innerRef
    } = _a, rest = __rest(_a, ["children", "className", "focusTrapOptions", "active", "paused", "preventScrollOnDeactivate", "innerRef"]);
    return React.createElement("div", Object.assign({ ref: this.divRef, className }, rest), children);
  }
};
FocusTrapBase.displayName = "FocusTrap";
FocusTrapBase.defaultProps = {
  active: true,
  paused: false,
  focusTrapOptions: {},
  preventScrollOnDeactivate: false
};
var FocusTrap = React.forwardRef((props, ref) => React.createElement(FocusTrapBase, Object.assign({ innerRef: ref }, props)));

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/GenerateId/GenerateId.js
var React2 = __toESM(require_react());
var currentId = 0;
var GenerateId = class extends React2.Component {
  constructor() {
    super(...arguments);
    this.id = `${this.props.prefix}${currentId++}`;
  }
  render() {
    return this.props.children(this.id);
  }
};
GenerateId.displayName = "GenerateId";
GenerateId.defaultProps = {
  prefix: "pf-random-id-"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/htmlConstants.js
var ASTERISK = "*";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/OUIA/ouia.js
var import_react = __toESM(require_react());
var uid = 0;
var ouiaPrefix = "OUIA-Generated-";
var ouiaIdByRoute = {};
function getOUIAProps(componentType, id, ouiaSafe = true) {
  return {
    "data-ouia-component-type": `PF4/${componentType}`,
    "data-ouia-safe": ouiaSafe,
    "data-ouia-component-id": id
  };
}
var useOUIAProps = (componentType, id, ouiaSafe = true, variant) => ({
  "data-ouia-component-type": `PF4/${componentType}`,
  "data-ouia-safe": ouiaSafe,
  "data-ouia-component-id": useOUIAId(componentType, id, variant)
});
var useOUIAId = (componentType, id, variant) => {
  const defaultOUIAId = (0, import_react.useMemo)(() => getDefaultOUIAId(componentType, variant), [componentType, variant]);
  return id !== null && id !== void 0 ? id : defaultOUIAId;
};
function getDefaultOUIAId(componentType, variant) {
  try {
    let key;
    if (typeof window !== "undefined") {
      key = `${window.location.href}-${componentType}-${variant || ""}`;
    } else {
      key = `${componentType}-${variant || ""}`;
    }
    if (!ouiaIdByRoute[key]) {
      ouiaIdByRoute[key] = 0;
    }
    return `${ouiaPrefix}${componentType}-${variant ? `${variant}-` : ""}${++ouiaIdByRoute[key]}`;
  } catch (exception) {
    return `${ouiaPrefix}${componentType}-${variant ? `${variant}-` : ""}${++uid}`;
  }
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/util.js
var ReactDOM = __toESM(require_react_dom());
function capitalize(input) {
  return input[0].toUpperCase() + input.substring(1);
}
function getUniqueId(prefix = "pf") {
  const uid2 = (/* @__PURE__ */ new Date()).getTime() + Math.random().toString(36).slice(2);
  return `${prefix}-${uid2}`;
}
function debounce(func, wait) {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}
function isElementInView(container, element, partial, strict = false) {
  if (!container || !element) {
    return false;
  }
  const containerBounds = container.getBoundingClientRect();
  const elementBounds = element.getBoundingClientRect();
  const containerBoundsLeft = Math.ceil(containerBounds.left);
  const containerBoundsRight = Math.floor(containerBounds.right);
  const elementBoundsLeft = Math.ceil(elementBounds.left);
  const elementBoundsRight = Math.floor(elementBounds.right);
  const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;
  const isPartiallyInView = (partial || !strict && containerBounds.width < elementBounds.width) && (elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft || elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight);
  return isTotallyInView || isPartiallyInView;
}
function sideElementIsOutOfView(container, element) {
  const containerBounds = container.getBoundingClientRect();
  const elementBounds = element.getBoundingClientRect();
  const containerBoundsLeft = Math.floor(containerBounds.left);
  const containerBoundsRight = Math.floor(containerBounds.right);
  const elementBoundsLeft = Math.floor(elementBounds.left);
  const elementBoundsRight = Math.floor(elementBounds.right);
  const isOffLeft = elementBoundsLeft < containerBoundsLeft;
  const isOffRight = elementBoundsRight > containerBoundsRight;
  let side = SIDE.NONE;
  if (isOffRight && isOffLeft) {
    side = SIDE.BOTH;
  } else if (isOffRight) {
    side = SIDE.RIGHT;
  } else if (isOffLeft) {
    side = SIDE.LEFT;
  }
  return side;
}
function fillTemplate(templateString, templateVars) {
  return templateString.replace(/\${(.*?)}/g, (_, match) => templateVars[match] || "");
}
function keyHandler(index, innerIndex, position, refsCollection, kids, custom = false) {
  if (!Array.isArray(kids)) {
    return;
  }
  const isMultiDimensional = refsCollection.filter((ref) => ref)[0].constructor === Array;
  let nextIndex = index;
  let nextInnerIndex = innerIndex;
  if (position === "up") {
    if (index === 0) {
      nextIndex = kids.length - 1;
    } else {
      nextIndex = index - 1;
    }
  } else if (position === "down") {
    if (index === kids.length - 1) {
      nextIndex = 0;
    } else {
      nextIndex = index + 1;
    }
  } else if (position === "left") {
    if (innerIndex === 0) {
      nextInnerIndex = refsCollection[index].length - 1;
    } else {
      nextInnerIndex = innerIndex - 1;
    }
  } else if (position === "right") {
    if (innerIndex === refsCollection[index].length - 1) {
      nextInnerIndex = 0;
    } else {
      nextInnerIndex = innerIndex + 1;
    }
  }
  if (refsCollection[nextIndex] === null || refsCollection[nextIndex] === void 0 || isMultiDimensional && (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === void 0)) {
    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);
  } else if (custom) {
    if (refsCollection[nextIndex].focus) {
      refsCollection[nextIndex].focus();
    }
    const element = ReactDOM.findDOMNode(refsCollection[nextIndex]);
    element.focus();
  } else if (position !== "tab") {
    if (isMultiDimensional) {
      refsCollection[nextIndex][nextInnerIndex].focus();
    } else {
      refsCollection[nextIndex].focus();
    }
  }
}
function findTabbableElements(containerRef, tababbleSelectors) {
  const tabbable3 = containerRef.current.querySelectorAll(tababbleSelectors);
  const list = Array.prototype.filter.call(tabbable3, function(item) {
    return item.tabIndex >= "0";
  });
  return list;
}
function getNextIndex(index, position, collection) {
  let nextIndex;
  if (position === "up") {
    if (index === 0) {
      nextIndex = collection.length - 1;
    } else {
      nextIndex = index - 1;
    }
  } else if (index === collection.length - 1) {
    nextIndex = 0;
  } else {
    nextIndex = index + 1;
  }
  if (collection[nextIndex] === void 0 || collection[nextIndex][0] === null) {
    return getNextIndex(nextIndex, position, collection);
  } else {
    return nextIndex;
  }
}
function pluralize(i, singular, plural) {
  if (!plural) {
    plural = `${singular}s`;
  }
  return `${i || 0} ${i === 1 ? singular : plural}`;
}
var setBreakpointCssVars = (mods, cssVar) => Object.entries(mods || {}).reduce((acc, [breakpoint, value]) => breakpoint === "default" ? Object.assign(Object.assign({}, acc), { [cssVar]: value }) : Object.assign(Object.assign({}, acc), { [`${cssVar}-on-${breakpoint}`]: value }), {});
var formatBreakpointMods = (mods, styles, stylePrefix = "", breakpoint, vertical) => {
  if (!mods) {
    return "";
  }
  if (breakpoint && !vertical) {
    if (breakpoint in mods) {
      return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpoint]}`)];
    }
    const breakpointsOrder = ["2xl", "xl", "lg", "md", "sm", "default"];
    const breakpointsIndex = breakpointsOrder.indexOf(breakpoint);
    for (let i = breakpointsIndex; i < breakpointsOrder.length; i++) {
      if (breakpointsOrder[i] in mods) {
        return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpointsOrder[i]]}`)];
      }
    }
    return "";
  }
  return Object.entries(mods || {}).map(([breakpoint2, mod]) => `${stylePrefix}${mod}${breakpoint2 !== "default" ? `-on-${breakpoint2}` : ""}${vertical && breakpoint2 !== "default" ? "-height" : ""}`).map(toCamel).map((mod) => mod.replace(/-?(\dxl)/gi, (_res, group) => `_${group}`)).map((modifierKey) => styles.modifiers[modifierKey]).filter(Boolean).join(" ");
};
var getVerticalBreakpoint = (height) => {
  if (height === null) {
    return null;
  }
  if (height >= globalHeightBreakpoints["2xl"]) {
    return "2xl";
  }
  if (height >= globalHeightBreakpoints.xl) {
    return "xl";
  }
  if (height >= globalHeightBreakpoints.lg) {
    return "lg";
  }
  if (height >= globalHeightBreakpoints.md) {
    return "md";
  }
  if (height >= globalHeightBreakpoints.sm) {
    return "sm";
  }
  return "default";
};
var getBreakpoint = (width) => {
  if (width === null) {
    return null;
  }
  if (width >= globalWidthBreakpoints["2xl"]) {
    return "2xl";
  }
  if (width >= globalWidthBreakpoints.xl) {
    return "xl";
  }
  if (width >= globalWidthBreakpoints.lg) {
    return "lg";
  }
  if (width >= globalWidthBreakpoints.md) {
    return "md";
  }
  if (width >= globalWidthBreakpoints.sm) {
    return "sm";
  }
  return "default";
};
var camelize = (s) => s.toUpperCase().replace("-", "").replace("_", "");
var toCamel = (s) => s.replace(/([-_][a-z])/gi, camelize);
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var getTextWidth = (text, node) => {
  const computedStyle = getComputedStyle(node);
  const getFontFromComputedStyle = () => {
    let computedFont = "";
    const fontStretchLookupTable = {
      "50%": "ultra-condensed",
      "62.5%": "extra-condensed",
      "75%": "condensed",
      "87.5%": "semi-condensed",
      "100%": "normal",
      "112.5%": "semi-expanded",
      "125%": "expanded",
      "150%": "extra-expanded",
      "200%": "ultra-expanded"
    };
    let fontStretch;
    if (computedStyle.fontStretch in fontStretchLookupTable) {
      fontStretch = fontStretchLookupTable[computedStyle.fontStretch];
    } else {
      fontStretch = "normal";
    }
    computedFont = computedStyle.fontStyle + " " + computedStyle.fontVariant + " " + computedStyle.fontWeight + " " + fontStretch + " " + computedStyle.fontSize + "/" + computedStyle.lineHeight + " " + computedStyle.fontFamily;
    return computedFont;
  };
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  context.font = computedStyle.font || getFontFromComputedStyle();
  return context.measureText(text).width;
};
var innerDimensions = (node) => {
  const computedStyle = getComputedStyle(node);
  let width = node.clientWidth;
  let height = node.clientHeight;
  height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);
  width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
  return { height, width };
};
var trimLeft = (node, value) => {
  const availableWidth = innerDimensions(node).width;
  let newValue = value;
  if (getTextWidth(value, node) > availableWidth) {
    while (getTextWidth(`...${newValue}`, node) > availableWidth) {
      newValue = newValue.substring(1);
    }
    if (node.value) {
      node.value = `...${newValue}`;
    } else {
      node.innerText = `...${newValue}`;
    }
  } else {
    if (node.value) {
      node.value = value;
    } else {
      node.innerText = value;
    }
  }
};
var preventedEvents = (events) => events.reduce((handlers, eventToPrevent) => Object.assign(Object.assign({}, handlers), { [eventToPrevent]: (event) => {
  event.preventDefault();
} }), {});

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/useIsomorphicLayout.js
var React3 = __toESM(require_react());
var useIsomorphicLayoutEffect = canUseDOM ? React3.useLayoutEffect : React3.useEffect;

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/Popper.js
var React6 = __toESM(require_react());
var ReactDOM3 = __toESM(require_react_dom());

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/react-popper/usePopper.js
var React4 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element) {
  const rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getWindow.js
function getWindow(node) {
  if (node.toString() !== "[object Window]") {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }
  return node;
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  const win = getWindow(node);
  const scrollLeft = win.pageXOffset;
  const scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/instanceOf.js
function isElement(node) {
  const OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  const OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return (isElement(element) ? element.ownerDocument : element.document).documentElement;
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getComputedStyle.js
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/isScrollParent.js
function isScrollParent(element) {
  const { overflow, overflowX, overflowY } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getCompositeRect.js
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed = false) {
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(elementOrVirtualElement);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  let scroll = { scrollLeft: 0, scrollTop: 0 };
  let offsets = { x: 0, y: 0 };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    // $FlowFixMe: need a better way to handle this...
    element.host || // ShadowRoot detected
    // $FlowFixMe: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/listScrollParents.js
function listScrollParents(element, list = []) {
  const scrollParent = getScrollParent(element);
  const isBody = getNodeName(scrollParent) === "body";
  const win = getWindow(scrollParent);
  const target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  const updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element).position === "fixed") {
    return null;
  }
  const offsetParent = element.offsetParent;
  if (offsetParent) {
    const html = getDocumentElement(offsetParent);
    if (getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && getComputedStyle2(html).position !== "static") {
      return html;
    }
  }
  return offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    const css2 = getComputedStyle2(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.willChange && css2.willChange !== "auto") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static") {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce((acc, placement) => acc.concat([`${placement}-${start}`, `${placement}-${end}`]), []);
var placements = [...basePlacements, auto].reduce((acc, placement) => acc.concat([placement, `${placement}-${start}`, `${placement}-${end}`]), []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [
  beforeRead,
  read,
  afterRead,
  beforeMain,
  main,
  afterMain,
  beforeWrite,
  write,
  afterWrite
];

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/orderModifiers.js
function order(modifiers) {
  const map = /* @__PURE__ */ new Map();
  const visited = /* @__PURE__ */ new Set();
  const result = [];
  modifiers.forEach((modifier) => {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    const requires = [...modifier.requires || [], ...modifier.requiresIfExists || []];
    requires.forEach((dep) => {
      if (!visited.has(dep)) {
        const depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach((modifier) => {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  const orderedModifiers = order(modifiers);
  return modifierPhases.reduce((acc, phase) => acc.concat(orderedModifiers.filter((modifier) => modifier.phase === phase)), []);
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/debounce.js
function debounce2(fn) {
  let pending;
  return () => {
    if (!pending) {
      pending = new Promise((resolve) => {
        Promise.resolve().then(() => {
          pending = void 0;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/mergeByName.js
function mergeByName(modifiers) {
  const merged = modifiers.reduce((merged2, current) => {
    const existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign(Object.assign(Object.assign({}, existing), current), { options: Object.assign(Object.assign({}, existing.options), current.options), data: Object.assign(Object.assign({}, existing.data), current.data) }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map((key) => merged[key]);
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getViewportRect.js
function getViewportRect(element) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const winScroll = getWindowScroll(element);
  const body = element.ownerDocument.body;
  const width = Math.max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = Math.max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  const y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += Math.max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return { width, height, x, y };
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/contains.js
function contains(parent, child) {
  const isShadow = Boolean(child.getRootNode && child.getRootNode().host);
  if (parent.contains(child)) {
    return true;
  } else if (isShadow) {
    let next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign(Object.assign({}, rect), { left: rect.x, top: rect.y, right: rect.x + rect.width, bottom: rect.y + rect.height });
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element) {
  const rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  const clippingParents2 = listScrollParents(getParentNode(element));
  const canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter((clippingParent) => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body");
}
function getClippingRect(element, boundary, rootBoundary) {
  const mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  const clippingParents2 = [...mainClippingParents, rootBoundary];
  const firstClippingParent = clippingParents2[0];
  const clippingRect = clippingParents2.reduce((accRect, clippingParent) => {
    const rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = Math.max(rect.top, accRect.top);
    accRect.right = Math.min(rect.right, accRect.right);
    accRect.bottom = Math.min(rect.bottom, accRect.bottom);
    accRect.left = Math.max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/computeOffsets.js
function computeOffsets({ reference: reference2, element, placement }) {
  const basePlacement = placement ? getBasePlacement(placement) : null;
  const variation = placement ? getVariation(placement) : null;
  const commonX = reference2.x + reference2.width / 2 - element.width / 2;
  const commonY = reference2.y + reference2.height / 2 - element.height / 2;
  let offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  const mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    const len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign(Object.assign({}, getFreshSideObject()), paddingObject);
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce((hashMap, key) => {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/detectOverflow.js
function detectOverflow(state, options = {}) {
  const { placement = state.placement, boundary = clippingParents, rootBoundary = viewport, elementContext = popper, altBoundary = false, padding = 0 } = options;
  const paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  const altContext = elementContext === popper ? reference : popper;
  const referenceElement = state.elements.reference;
  const popperRect = state.rects.popper;
  const element = state.elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  const referenceClientRect = getBoundingClientRect(referenceElement);
  const popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  const popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets2));
  const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  const overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  const offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    const offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach((key) => {
      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      const axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/index.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements(...args) {
  return !args.some((element) => !(element && typeof element.getBoundingClientRect === "function"));
}
function popperGenerator(generatorOptions = {}) {
  const { defaultModifiers: defaultModifiers2 = [], defaultOptions = DEFAULT_OPTIONS } = generatorOptions;
  return function createPopper3(reference2, popper2, options = defaultOptions) {
    let state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    let effectCleanupFns = [];
    let isDestroyed = false;
    const instance = {
      state,
      setOptions(options2) {
        cleanupModifierEffects();
        state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions), state.options), options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        const orderedModifiers = orderModifiers(mergeByName([...defaultModifiers2, ...state.options.modifiers]));
        state.orderedModifiers = orderedModifiers.filter((m) => m.enabled);
        if (false) {
          const modifiers = uniqueBy([...orderedModifiers, ...state.options.modifiers], ({ name }) => name);
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            const flipModifier = state.orderedModifiers.find(({ name }) => name === "flip");
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          const { marginTop, marginRight, marginBottom, marginLeft } = getComputedStyle2(popper2);
          if ([marginTop, marginRight, marginBottom, marginLeft].some((margin) => parseFloat(margin))) {
            console.warn([
              'Popper: CSS "margin" styles cannot be used to apply padding',
              "between the popper and its reference element or boundary.",
              "To replicate margin, use the `offset` modifier, as well as",
              "the `padding` option in the `preventOverflow` and `flip`",
              "modifiers."
            ].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate() {
        if (isDestroyed) {
          return;
        }
        const { reference: reference3, popper: popper3 } = state.elements;
        if (!areValidElements(reference3, popper3)) {
          if (false) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach((modifier) => state.modifiersData[modifier.name] = Object.assign({}, modifier.data));
        let __debug_loops__ = 0;
        for (let index = 0; index < state.orderedModifiers.length; index++) {
          if (false) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          const { fn, options: options2 = {}, name } = state.orderedModifiers[index];
          if (typeof fn === "function") {
            state = fn({ state, options: options2, name, instance }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce2(() => new Promise((resolve) => {
        instance.forceUpdate();
        resolve(state);
      })),
      destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (false) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then((state2) => {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(({ name, options: options2 = {}, effect: effect4 }) => {
        if (typeof effect4 === "function") {
          const cleanupFn = effect4({ state, name, instance, options: options2 });
          const noopFn = () => {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach((fn) => fn());
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/eventListeners.js
var passive = { passive: true };
function effect({ state, instance, options }) {
  const { scroll = true, resize = true } = options;
  const window2 = getWindow(state.elements.popper);
  const scrollParents = [...state.scrollParents.reference, ...state.scrollParents.popper];
  if (scroll) {
    scrollParents.forEach((scrollParent) => {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return () => {
    if (scroll) {
      scrollParents.forEach((scrollParent) => {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: () => {
  },
  effect,
  data: {}
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/popperOffsets.js
function popperOffsets({ state, name }) {
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsets({ x, y }) {
  const win = window;
  const dpr = win.devicePixelRatio || 1;
  return {
    x: Math.round(x * dpr) / dpr || 0,
    y: Math.round(y * dpr) / dpr || 0
  };
}
function mapToStyles({ popper: popper2, popperRect, placement, offsets, position, gpuAcceleration, adaptive }) {
  let { x, y } = roundOffsets(offsets);
  const hasX = offsets.hasOwnProperty("x");
  const hasY = offsets.hasOwnProperty("y");
  let sideX = left;
  let sideY = top;
  const win = window;
  if (adaptive) {
    let offsetParent = getOffsetParent(popper2);
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
    }
    if (placement === top) {
      sideY = bottom;
      y -= offsetParent.clientHeight - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left) {
      sideX = right;
      x -= offsetParent.clientWidth - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  const commonStyles = Object.assign({ position }, adaptive && unsetSides);
  if (gpuAcceleration) {
    return Object.assign(Object.assign({}, commonStyles), {
      [sideY]: hasY ? "0" : "",
      [sideX]: hasX ? "0" : "",
      // Layer acceleration can disable subpixel rendering which causes slightly
      // blurry text on low PPI displays, so we want to use 2D transforms
      // instead
      transform: (win.devicePixelRatio || 1) < 2 ? `translate(${x}px, ${y}px)` : `translate3d(${x}px, ${y}px, 0)`
    });
  }
  return Object.assign(Object.assign({}, commonStyles), { [sideY]: hasY ? `${y}px` : "", [sideX]: hasX ? `${x}px` : "", transform: "" });
}
function computeStyles({ state, options }) {
  const { gpuAcceleration = true, adaptive = true } = options;
  if (false) {
    const transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some((property) => transitionProperty.indexOf(property) >= 0)) {
      console.warn([
        "Popper: Detected CSS transitions on at least one of the following",
        'CSS properties: "transform", "top", "right", "bottom", "left".',
        "\n\n",
        'Disable the "computeStyles" modifier\'s `adaptive` option to allow',
        "for smooth transitions, or remove these properties from the CSS",
        "transition declaration on the popper element if only transitioning",
        "opacity or background-color for example.",
        "\n\n",
        "We recommend using the popper element as a wrapper around an inner",
        "element that can have any CSS property transitioned for animations."
      ].join(" "));
    }
  }
  const commonStyles = {
    placement: getBasePlacement(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), { offsets: state.modifiersData.popperOffsets, position: state.options.strategy, adaptive })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), { offsets: state.modifiersData.arrow, position: "absolute", adaptive: false })));
  }
  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), { "data-popper-placement": state.placement });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/applyStyles.js
function applyStyles({ state }) {
  Object.keys(state.elements).forEach((name) => {
    const style = state.styles[name] || {};
    const attributes = state.attributes[name] || {};
    const element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach((name2) => {
      const value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect2({ state }) {
  const initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return () => {
    Object.keys(state.elements).forEach((name) => {
      const element = state.elements[name];
      const attributes = state.attributes[name] || {};
      const styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      const style = styleProperties.reduce((style2, property) => {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach((attribute) => {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect2,
  requires: ["computeStyles"]
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  const basePlacement = getBasePlacement(placement);
  const invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  let [skidding, distance] = typeof offset2 === "function" ? offset2(Object.assign(Object.assign({}, rects), { placement })) : offset2;
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? { x: distance, y: skidding } : { x: skidding, y: distance };
}
function offset({ state, options, name }) {
  const { offset: offset2 = [0, 0] } = options;
  const data = placements.reduce((acc, placement) => {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  const { x, y } = data[state.placement];
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getOppositePlacement.js
var hash = { left: "right", right: "left", bottom: "top", top: "bottom" };
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash[matched]);
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getOppositeVariationPlacement.js
var hash2 = { start: "end", end: "start" };
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash2[matched]);
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options = {}) {
  const { placement, boundary, rootBoundary, padding, flipVariations, allowedAutoPlacements = placements } = options;
  const variation = getVariation(placement);
  const placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter((placement2) => getVariation(placement2) === variation) : basePlacements;
  let allowedPlacements = placements2.filter((placement2) => allowedAutoPlacements.indexOf(placement2) >= 0);
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (false) {
      console.error([
        "Popper: The `allowedAutoPlacements` option did not allow any",
        "placements. Ensure the `placement` option matches the variation",
        "of the allowed placements.",
        'For example, "auto" cannot be used to allow "bottom-start".',
        'Use "auto-start" instead.'
      ].join(" "));
    }
  }
  const overflows = allowedPlacements.reduce((acc, placement2) => {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort((a, b) => overflows[a] - overflows[b]);
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  const oppositePlacement = getOppositePlacement(placement);
  return [
    getOppositeVariationPlacement(placement),
    oppositePlacement,
    getOppositeVariationPlacement(oppositePlacement)
  ];
}
function flip({ state, options, name }) {
  if (state.modifiersData[name]._skip) {
    return;
  }
  const { mainAxis: checkMainAxis = true, altAxis: checkAltAxis = true, fallbackPlacements: specifiedFallbackPlacements, padding, boundary, rootBoundary, altBoundary, flipVariations = true, allowedAutoPlacements } = options;
  const preferredPlacement = state.options.placement;
  const basePlacement = getBasePlacement(preferredPlacement);
  const isBasePlacement = basePlacement === preferredPlacement;
  const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  const placements2 = [preferredPlacement, ...fallbackPlacements].reduce((acc, placement) => acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
    placement,
    boundary,
    rootBoundary,
    padding,
    flipVariations,
    allowedAutoPlacements
  }) : placement), []);
  const referenceRect = state.rects.reference;
  const popperRect = state.rects.popper;
  const checksMap = /* @__PURE__ */ new Map();
  let makeFallbackChecks = true;
  let firstFittingPlacement = placements2[0];
  for (let i = 0; i < placements2.length; i++) {
    const placement = placements2[i];
    const basePlacement2 = getBasePlacement(placement);
    const isStartVariation = getVariation(placement) === start;
    const isVertical = [top, bottom].indexOf(basePlacement2) >= 0;
    const len = isVertical ? "width" : "height";
    const overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    let mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    const altVariationSide = getOppositePlacement(mainVariationSide);
    const checks = [];
    if (checkMainAxis) {
      checks.push(overflow[basePlacement2] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every((check) => check)) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    const numberOfChecks = flipVariations ? 3 : 1;
    for (let i = numberOfChecks; i > 0; i--) {
      const fittingPlacement = placements2.find((placement) => {
        const checks = checksMap.get(placement);
        if (checks) {
          return checks.slice(0, i).every((check) => check);
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        break;
      }
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: { _skip: false }
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/within.js
function within(min, value, max) {
  return Math.max(min, Math.min(value, max));
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/preventOverflow.js
function preventOverflow({ state, options, name }) {
  const { mainAxis: checkMainAxis = true, altAxis: checkAltAxis = false, boundary, rootBoundary, altBoundary, padding, tether = true, tetherOffset = 0 } = options;
  const overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  const basePlacement = getBasePlacement(state.placement);
  const variation = getVariation(state.placement);
  const isBasePlacement = !variation;
  const mainAxis = getMainAxisFromPlacement(basePlacement);
  const altAxis = getAltAxis(mainAxis);
  const popperOffsets2 = state.modifiersData.popperOffsets;
  const referenceRect = state.rects.reference;
  const popperRect = state.rects.popper;
  const tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign(Object.assign({}, state.rects), { placement: state.placement })) : tetherOffset;
  const data = { x: 0, y: 0 };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    const mainSide = mainAxis === "y" ? top : left;
    const altSide = mainAxis === "y" ? bottom : right;
    const len = mainAxis === "y" ? "height" : "width";
    const offset2 = popperOffsets2[mainAxis];
    const min = popperOffsets2[mainAxis] + overflow[mainSide];
    const max = popperOffsets2[mainAxis] - overflow[altSide];
    const additive = tether ? -popperRect[len] / 2 : 0;
    const minLen = variation === start ? referenceRect[len] : popperRect[len];
    const maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    const arrowElement = state.elements.arrow;
    const arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : { width: 0, height: 0 };
    const arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    const arrowPaddingMin = arrowPaddingObject[mainSide];
    const arrowPaddingMax = arrowPaddingObject[altSide];
    const arrowLen = within(0, referenceRect[len], arrowRect[len]);
    const minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    const maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    const arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    const clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    const offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    const tetherMin = popperOffsets2[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    const tetherMax = popperOffsets2[mainAxis] + maxOffset - offsetModifierValue;
    const preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset2, tether ? Math.max(max, tetherMax) : max);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    const mainSide = mainAxis === "x" ? top : left;
    const altSide = mainAxis === "x" ? bottom : right;
    const offset2 = popperOffsets2[altAxis];
    const min = offset2 + overflow[mainSide];
    const max = offset2 - overflow[altSide];
    const preventedOffset = within(min, offset2, max);
    popperOffsets2[altAxis] = preventedOffset;
    data[altAxis] = preventedOffset - offset2;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/arrow.js
function arrow({ state, name }) {
  const arrowElement = state.elements.arrow;
  const popperOffsets2 = state.modifiersData.popperOffsets;
  const basePlacement = getBasePlacement(state.placement);
  const axis = getMainAxisFromPlacement(basePlacement);
  const isVertical = [left, right].indexOf(basePlacement) >= 0;
  const len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  const paddingObject = state.modifiersData[`${name}#persistent`].padding;
  const arrowRect = getLayoutRect(arrowElement);
  const minProp = axis === "y" ? top : left;
  const maxProp = axis === "y" ? bottom : right;
  const endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  const startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  const arrowOffsetParent = getOffsetParent(arrowElement);
  const clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  const centerToReference = endDiff / 2 - startDiff / 2;
  const min = paddingObject[minProp];
  const max = clientSize - arrowRect[len] - paddingObject[maxProp];
  const center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  const offset2 = within(min, center, max);
  const axisProp = axis;
  state.modifiersData[name] = {
    [axisProp]: offset2,
    centerOffset: offset2 - center
  };
}
function effect3({ state, options, name }) {
  let { element: arrowElement = "[data-popper-arrow]", padding = 0 } = options;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (false) {
    if (!isHTMLElement(arrowElement)) {
      console.error([
        'Popper: "arrow" element must be an HTMLElement (not an SVGElement).',
        "To use an SVG arrow, wrap it in an HTMLElement that will be used as",
        "the arrow."
      ].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (false) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
  state.modifiersData[`${name}#persistent`] = {
    padding: mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements))
  };
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect3,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets = { x: 0, y: 0 }) {
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some((side) => overflow[side] >= 0);
}
function hide({ state, name }) {
  const referenceRect = state.rects.reference;
  const popperRect = state.rects.popper;
  const preventedOffsets = state.modifiersData.preventOverflow;
  const referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  const popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  const referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  const popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  const isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  const hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), { "data-popper-reference-hidden": isReferenceHidden, "data-popper-escaped": hasPopperEscaped });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/popper.js
var defaultModifiers = [
  eventListeners_default,
  popperOffsets_default,
  computeStyles_default,
  applyStyles_default,
  offset_default,
  flip_default,
  preventOverflow_default,
  arrow_default,
  hide_default
];
var createPopper2 = popperGenerator({ defaultModifiers });

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/react-popper/usePopper.js
var isEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);
var fromEntries = (entries) => entries.reduce((acc, [key, value]) => {
  acc[key] = value;
  return acc;
}, {});
var EMPTY_MODIFIERS = [];
var usePopper = (referenceElement, popperElement, options = {}) => {
  const prevOptions = React4.useRef(null);
  const optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || "bottom",
    strategy: options.strategy || "absolute",
    modifiers: options.modifiers || EMPTY_MODIFIERS
  };
  const [state, setState] = React4.useState({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: "0",
        top: "0"
      }
    },
    attributes: {}
  });
  const updateStateModifier = React4.useMemo(() => ({
    name: "updateState",
    enabled: true,
    phase: "write",
    // eslint-disable-next-line no-shadow
    fn: ({ state: state2 }) => {
      const elements = Object.keys(state2.elements);
      setState({
        styles: fromEntries(elements.map((element) => [element, state2.styles[element] || {}])),
        attributes: fromEntries(elements.map((element) => [element, state2.attributes[element]]))
      });
    },
    requires: ["computeStyles"]
  }), []);
  const popperOptions = React4.useMemo(() => {
    const newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [...optionsWithDefaults.modifiers, updateStateModifier, { name: "applyStyles", enabled: false }]
    };
    if (isEqual(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [
    optionsWithDefaults.onFirstUpdate,
    optionsWithDefaults.placement,
    optionsWithDefaults.strategy,
    optionsWithDefaults.modifiers,
    updateStateModifier
  ]);
  const popperInstanceRef = React4.useRef();
  useIsomorphicLayoutEffect(() => {
    if (popperInstanceRef && popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useIsomorphicLayoutEffect(() => {
    if (referenceElement == null || popperElement == null) {
      return;
    }
    const createPopper3 = options.createPopper || createPopper2;
    const popperInstance = createPopper3(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return () => {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/FindRefWrapper.js
var React5 = __toESM(require_react());
var ReactDOM2 = __toESM(require_react_dom());
var FindRefWrapper = class extends React5.Component {
  componentDidMount() {
    const root = ReactDOM2.findDOMNode(this);
    this.props.onFoundRef(root);
  }
  render() {
    return this.props.children || null;
  }
};
FindRefWrapper.displayName = "FindRefWrapper";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/Popper/Popper.js
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Popper/Popper.css";
var hash3 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom",
  "top-start": "bottom-end",
  "top-end": "bottom-start",
  "bottom-start": "top-end",
  "bottom-end": "top-start",
  "left-start": "right-end",
  "left-end": "right-start",
  "right-start": "left-end",
  "right-end": "left-start"
};
var getOppositePlacement2 = (placement) => placement.replace(/left|right|bottom|top|top-start|top-end|bottom-start|bottom-end|right-start|right-end|left-start|left-end/g, (matched) => hash3[matched]);
var getOpacityTransition = (animationDuration) => `opacity ${animationDuration}ms cubic-bezier(.54, 1.5, .38, 1.11)`;
var Popper = ({ trigger, popper: popper2, popperMatchesTriggerWidth = true, direction = "down", position = "left", placement, appendTo = () => document.body, zIndex = 9999, isVisible = true, positionModifiers, distance = 0, onMouseEnter, onMouseLeave, onFocus, onBlur, onDocumentClick, onTriggerClick, onTriggerEnter, onPopperClick, onPopperMouseEnter, onPopperMouseLeave, onDocumentKeyDown, enableFlip = true, flipBehavior = "flip", reference: reference2, removeFindDomNode = false, popperRef }) => {
  const [triggerElement, setTriggerElement] = React6.useState(null);
  const [refElement, setRefElement] = React6.useState(null);
  const [popperElement, setPopperElement] = React6.useState(null);
  const [ready, setReady] = React6.useState(false);
  const refOrTrigger = refElement || triggerElement;
  const onDocumentClickCallback = React6.useCallback((event) => onDocumentClick(event, refOrTrigger, popperElement), [isVisible, triggerElement, refElement, popperElement, onDocumentClick]);
  React6.useEffect(() => {
    setReady(true);
  }, []);
  React6.useEffect(() => {
    if (reference2) {
      if (reference2.current) {
        setRefElement(reference2.current);
      } else if (typeof reference2 === "function") {
        setRefElement(reference2());
      }
    }
  }, [reference2]);
  React6.useEffect(() => {
    if (popperRef) {
      if (popperRef.current) {
        setPopperElement(popperRef.current);
      } else if (typeof popperRef === "function") {
        setPopperElement(popperRef());
      }
    }
  }, [isVisible, popperRef]);
  const addEventListener = (listener, element, event, capture = false) => {
    if (listener && element) {
      element.addEventListener(event, listener, { capture });
    }
  };
  const removeEventListener = (listener, element, event, capture = false) => {
    if (listener && element) {
      element.removeEventListener(event, listener, { capture });
    }
  };
  React6.useEffect(() => {
    addEventListener(onMouseEnter, refOrTrigger, "mouseenter");
    addEventListener(onMouseLeave, refOrTrigger, "mouseleave");
    addEventListener(onFocus, refOrTrigger, "focus");
    addEventListener(onBlur, refOrTrigger, "blur");
    addEventListener(onTriggerClick, refOrTrigger, "click");
    addEventListener(onTriggerEnter, refOrTrigger, "keydown");
    addEventListener(onPopperClick, popperElement, "click");
    addEventListener(onPopperMouseEnter, popperElement, "mouseenter");
    addEventListener(onPopperMouseLeave, popperElement, "mouseleave");
    onDocumentClick && addEventListener(onDocumentClickCallback, document, "click", true);
    addEventListener(onDocumentKeyDown, document, "keydown", true);
    const observer = new MutationObserver(() => {
      update && update();
    });
    popperElement && observer.observe(popperElement, { attributes: true, childList: true, subtree: true });
    return () => {
      removeEventListener(onMouseEnter, refOrTrigger, "mouseenter");
      removeEventListener(onMouseLeave, refOrTrigger, "mouseleave");
      removeEventListener(onFocus, refOrTrigger, "focus");
      removeEventListener(onBlur, refOrTrigger, "blur");
      removeEventListener(onTriggerClick, refOrTrigger, "click");
      removeEventListener(onTriggerEnter, refOrTrigger, "keydown");
      removeEventListener(onPopperClick, popperElement, "click");
      removeEventListener(onPopperMouseEnter, popperElement, "mouseenter");
      removeEventListener(onPopperMouseLeave, popperElement, "mouseleave");
      onDocumentClick && removeEventListener(onDocumentClickCallback, document, "click", true);
      removeEventListener(onDocumentKeyDown, document, "keydown", true);
      observer.disconnect();
    };
  }, [
    triggerElement,
    popperElement,
    onMouseEnter,
    onMouseLeave,
    onFocus,
    onBlur,
    onTriggerClick,
    onTriggerEnter,
    onPopperClick,
    onPopperMouseEnter,
    onPopperMouseLeave,
    onDocumentClick,
    onDocumentKeyDown,
    refElement
  ]);
  const getPlacement = () => {
    if (placement) {
      return placement;
    }
    let convertedPlacement = direction === "up" ? "top" : "bottom";
    if (position !== "center") {
      convertedPlacement = `${convertedPlacement}-${position === "right" ? "end" : "start"}`;
    }
    return convertedPlacement;
  };
  const getPlacementMemo = React6.useMemo(getPlacement, [direction, position, placement]);
  const getOppositePlacementMemo = React6.useMemo(() => getOppositePlacement2(getPlacement()), [
    direction,
    position,
    placement
  ]);
  const sameWidthMod = React6.useMemo(() => ({
    name: "sameWidth",
    enabled: popperMatchesTriggerWidth,
    phase: "beforeWrite",
    requires: ["computeStyles"],
    fn: ({ state }) => {
      state.styles.popper.width = `${state.rects.reference.width}px`;
    },
    effect: ({ state }) => {
      state.elements.popper.style.width = `${state.elements.reference.offsetWidth}px`;
      return () => {
      };
    }
  }), [popperMatchesTriggerWidth]);
  const { styles: popperStyles, attributes, update, forceUpdate } = usePopper(refOrTrigger, popperElement, {
    placement: getPlacementMemo,
    modifiers: [
      {
        name: "offset",
        options: {
          offset: [0, distance]
        }
      },
      {
        name: "preventOverflow",
        enabled: false
      },
      {
        // adds attribute [data-popper-reference-hidden] to the popper element which can be used to hide it using CSS
        name: "hide",
        enabled: true
      },
      {
        name: "flip",
        enabled: getPlacementMemo.startsWith("auto") || enableFlip,
        options: {
          fallbackPlacements: flipBehavior === "flip" ? [getOppositePlacementMemo] : flipBehavior
        }
      },
      sameWidthMod
    ]
  });
  React6.useEffect(() => {
    forceUpdate && forceUpdate();
  }, [popper2]);
  const modifierFromPopperPosition = () => {
    if (attributes && attributes.popper && attributes.popper["data-popper-placement"]) {
      const popperPlacement = attributes.popper["data-popper-placement"];
      return positionModifiers[popperPlacement];
    }
    return positionModifiers.top;
  };
  const options = Object.assign({ className: css(popper2.props && popper2.props.className, positionModifiers && modifierFromPopperPosition()), style: Object.assign(Object.assign(Object.assign({}, popper2.props && popper2.props.style || {}), popperStyles.popper), { zIndex }) }, attributes.popper);
  const menuWithPopper = React6.cloneElement(popper2, options);
  const getTarget = () => {
    if (typeof appendTo === "function") {
      return appendTo();
    }
    return appendTo;
  };
  let popperPortal;
  if (removeFindDomNode) {
    popperPortal = React6.createElement("div", { style: { display: "contents" }, ref: (node) => setPopperElement(node === null || node === void 0 ? void 0 : node.firstElementChild) }, menuWithPopper);
  } else if (popperRef) {
    popperPortal = menuWithPopper;
  } else {
    popperPortal = React6.createElement(FindRefWrapper, { onFoundRef: (foundRef) => setPopperElement(foundRef) }, menuWithPopper);
  }
  return React6.createElement(
    React6.Fragment,
    null,
    !reference2 && trigger && React6.isValidElement(trigger) && !removeFindDomNode && React6.createElement(FindRefWrapper, { onFoundRef: (foundRef) => setTriggerElement(foundRef) }, trigger),
    !reference2 && trigger && React6.isValidElement(trigger) && removeFindDomNode && React6.createElement("div", { style: { display: "contents" }, ref: (node) => setTriggerElement(node === null || node === void 0 ? void 0 : node.firstElementChild) }, trigger),
    ready && isVisible && ReactDOM3.createPortal(popperPortal, getTarget())
  );
};
Popper.displayName = "Popper";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/KeyboardHandler.js
var React7 = __toESM(require_react());
var handleArrows = (event, navigableElements, isActiveElement = (element) => document.activeElement.contains(element), getFocusableElement = (element) => element, validSiblingTags = ["A", "BUTTON", "INPUT"], noVerticalArrowHandling = false, noHorizontalArrowHandling = false, updateTabIndex = true, onlyTraverseSiblings = true) => {
  const activeElement = document.activeElement;
  const key = event.key;
  let moveTarget = null;
  if (!noVerticalArrowHandling) {
    if (["ArrowUp", "ArrowDown"].includes(key)) {
      event.preventDefault();
      event.stopImmediatePropagation();
      let currentIndex = -1;
      navigableElements.forEach((element, index) => {
        if (isActiveElement(element)) {
          let increment = 0;
          while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {
            key === "ArrowUp" ? increment-- : increment++;
            currentIndex = index + increment;
            if (currentIndex >= navigableElements.length) {
              currentIndex = 0;
            }
            if (currentIndex < 0) {
              currentIndex = navigableElements.length - 1;
            }
            moveTarget = getFocusableElement(navigableElements[currentIndex]);
          }
        }
      });
    }
  }
  if (!noHorizontalArrowHandling) {
    if (["ArrowLeft", "ArrowRight"].includes(key)) {
      event.preventDefault();
      event.stopImmediatePropagation();
      let currentIndex = -1;
      navigableElements.forEach((element, index) => {
        if (isActiveElement(element)) {
          const activeRow = navigableElements[index].querySelectorAll(validSiblingTags.join(","));
          if (!activeRow.length || onlyTraverseSiblings) {
            let nextSibling = activeElement;
            while (nextSibling) {
              nextSibling = key === "ArrowLeft" ? nextSibling.previousElementSibling : nextSibling.nextElementSibling;
              if (nextSibling) {
                if (validSiblingTags.includes(nextSibling.tagName)) {
                  moveTarget = nextSibling;
                  break;
                }
              }
            }
          } else {
            activeRow.forEach((focusableElement, index2) => {
              if (event.target === focusableElement) {
                const increment = key === "ArrowLeft" ? -1 : 1;
                currentIndex = index2 + increment;
                if (currentIndex >= activeRow.length) {
                  currentIndex = 0;
                }
                if (currentIndex < 0) {
                  currentIndex = activeRow.length - 1;
                }
                moveTarget = activeRow[currentIndex];
              }
            });
          }
        }
      });
    }
  }
  if (moveTarget) {
    if (updateTabIndex) {
      activeElement.tabIndex = -1;
      moveTarget.tabIndex = 0;
    }
    moveTarget.focus();
  }
};
var setTabIndex = (options) => {
  if (options && options.length > 0) {
    options.forEach((option) => {
      option.tabIndex = -1;
    });
    options[0].tabIndex = 0;
  }
};
var KeyboardHandler = class extends React7.Component {
  constructor() {
    super(...arguments);
    this.keyHandler = (event) => {
      const { isEventFromContainer } = this.props;
      if (isEventFromContainer ? !isEventFromContainer(event) : !this._isEventFromContainer(event)) {
        return;
      }
      const { isActiveElement, getFocusableElement, noVerticalArrowHandling, noHorizontalArrowHandling, noEnterHandling, noSpaceHandling, updateTabIndex, validSiblingTags, additionalKeyHandler, createNavigableElements, onlyTraverseSiblings } = this.props;
      additionalKeyHandler && additionalKeyHandler(event);
      const navigableElements = createNavigableElements();
      if (!navigableElements) {
        console.warn("No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.");
        return;
      }
      const key = event.key;
      if (!noEnterHandling) {
        if (key === "Enter") {
          event.preventDefault();
          event.stopImmediatePropagation();
          document.activeElement.click();
        }
      }
      if (!noSpaceHandling) {
        if (key === " ") {
          event.preventDefault();
          event.stopImmediatePropagation();
          document.activeElement.click();
        }
      }
      handleArrows(event, navigableElements, isActiveElement, getFocusableElement, validSiblingTags, noVerticalArrowHandling, noHorizontalArrowHandling, updateTabIndex, onlyTraverseSiblings);
    };
    this._isEventFromContainer = (event) => {
      const { containerRef } = this.props;
      return containerRef.current && containerRef.current.contains(event.target);
    };
  }
  componentDidMount() {
    if (canUseDOM) {
      window.addEventListener("keydown", this.keyHandler);
    }
  }
  componentWillUnmount() {
    if (canUseDOM) {
      window.removeEventListener("keydown", this.keyHandler);
    }
  }
  render() {
    return null;
  }
};
KeyboardHandler.displayName = "KeyboardHandler";
KeyboardHandler.defaultProps = {
  containerRef: null,
  createNavigableElements: () => null,
  isActiveElement: (navigableElement) => document.activeElement === navigableElement,
  getFocusableElement: (navigableElement) => navigableElement,
  validSiblingTags: ["BUTTON", "A"],
  onlyTraverseSiblings: true,
  updateTabIndex: true,
  noHorizontalArrowHandling: false,
  noVerticalArrowHandling: false,
  noEnterHandling: false,
  noSpaceHandling: false
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/resizeObserver.js
var getResizeObserver = (containerRefElement, handleResize, useRequestAnimationFrame = true) => {
  let unobserve;
  if (canUseDOM) {
    const { ResizeObserver } = window;
    if (containerRefElement && ResizeObserver) {
      const resizeObserver = new ResizeObserver((entries) => {
        if (useRequestAnimationFrame) {
          window.requestAnimationFrame(() => {
            if (Array.isArray(entries) && entries.length > 0) {
              handleResize();
            }
          });
        } else {
          if (Array.isArray(entries) && entries.length > 0) {
            handleResize();
          }
        }
      });
      resizeObserver.observe(containerRefElement);
      unobserve = () => resizeObserver.unobserve(containerRefElement);
    } else {
      window.addEventListener("resize", handleResize);
      unobserve = () => window.removeEventListener("resize", handleResize);
    }
  }
  return () => {
    if (unobserve) {
      unobserve();
    }
  };
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/useInterval.js
var React8 = __toESM(require_react());
function useInterval(callback, delay3) {
  const savedCallback = React8.useRef(() => {
  });
  React8.useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);
  React8.useEffect(() => {
    function tick() {
      savedCallback.current();
    }
    if (delay3 !== null) {
      const id = setInterval(tick, delay3);
      return () => clearInterval(id);
    }
  }, [delay3]);
}

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/datetimeUtils.js
var isValidDate = (date) => Boolean(date && !isNaN(date));

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Title/Title.js
var React9 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Title/title.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Title/title.css";
var title_default = {
  "modifiers": {
    "4xl": "pf-m-4xl",
    "3xl": "pf-m-3xl",
    "2xl": "pf-m-2xl",
    "xl": "pf-m-xl",
    "lg": "pf-m-lg",
    "md": "pf-m-md",
    "overpassFont": "pf-m-overpass-font"
  },
  "title": "pf-c-title"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Title/Title.js
var TitleSizes;
(function(TitleSizes2) {
  TitleSizes2["md"] = "md";
  TitleSizes2["lg"] = "lg";
  TitleSizes2["xl"] = "xl";
  TitleSizes2["2xl"] = "2xl";
  TitleSizes2["3xl"] = "3xl";
  TitleSizes2["4xl"] = "4xl";
})(TitleSizes || (TitleSizes = {}));
var headingLevelSizeMap;
(function(headingLevelSizeMap2) {
  headingLevelSizeMap2["h1"] = "2xl";
  headingLevelSizeMap2["h2"] = "xl";
  headingLevelSizeMap2["h3"] = "lg";
  headingLevelSizeMap2["h4"] = "md";
  headingLevelSizeMap2["h5"] = "md";
  headingLevelSizeMap2["h6"] = "md";
})(headingLevelSizeMap || (headingLevelSizeMap = {}));
var Title = (_a) => {
  var { className = "", children = "", headingLevel: HeadingLevel, size = headingLevelSizeMap[HeadingLevel], ouiaId, ouiaSafe = true } = _a, props = __rest(_a, ["className", "children", "headingLevel", "size", "ouiaId", "ouiaSafe"]);
  const ouiaProps = useOUIAProps(Title.displayName, ouiaId, ouiaSafe);
  return React9.createElement(HeadingLevel, Object.assign({}, ouiaProps, props, { className: css(title_default.title, size && title_default.modifiers[size], className) }), children);
};
Title.displayName = "Title";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Spinner/Spinner.js
var React10 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Spinner/spinner.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Spinner/spinner.css";
var spinner_default = {
  "modifiers": {
    "inline": "pf-m-inline",
    "sm": "pf-m-sm",
    "md": "pf-m-md",
    "lg": "pf-m-lg",
    "xl": "pf-m-xl"
  },
  "spinner": "pf-c-spinner",
  "spinnerClipper": "pf-c-spinner__clipper",
  "spinnerLeadBall": "pf-c-spinner__lead-ball",
  "spinnerPath": "pf-c-spinner__path",
  "spinnerTailBall": "pf-c-spinner__tail-ball"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Spinner/Spinner.js
var spinnerSize;
(function(spinnerSize2) {
  spinnerSize2["sm"] = "sm";
  spinnerSize2["md"] = "md";
  spinnerSize2["lg"] = "lg";
  spinnerSize2["xl"] = "xl";
})(spinnerSize || (spinnerSize = {}));
var Spinner = (_a) => {
  var {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    className = "",
    size = "xl",
    "aria-valuetext": ariaValueText = "Loading...",
    isSVG = false,
    diameter,
    isInline = false,
    "aria-label": ariaLabel,
    "aria-labelledBy": ariaLabelledBy
  } = _a, props = __rest(_a, ["className", "size", "aria-valuetext", "isSVG", "diameter", "isInline", "aria-label", "aria-labelledBy"]);
  const Component19 = isSVG ? "svg" : "span";
  return React10.createElement(Component19, Object.assign({ className: css(spinner_default.spinner, isInline ? spinner_default.modifiers.inline : spinner_default.modifiers[size], className), role: "progressbar", "aria-valuetext": ariaValueText }, isSVG && { viewBox: "0 0 100 100" }, diameter && { style: { "--pf-c-spinner--diameter": diameter } }, ariaLabel && { "aria-label": ariaLabel }, ariaLabelledBy && { "aria-labelledBy": ariaLabelledBy }, !ariaLabel && !ariaLabelledBy && { "aria-label": "Contents" }, props), isSVG ? React10.createElement("circle", { className: spinner_default.spinnerPath, cx: "50", cy: "50", r: "45", fill: "none" }) : React10.createElement(
    React10.Fragment,
    null,
    React10.createElement("span", { className: css(spinner_default.spinnerClipper) }),
    React10.createElement("span", { className: css(spinner_default.spinnerLeadBall) }),
    React10.createElement("span", { className: css(spinner_default.spinnerTailBall) })
  ));
};
Spinner.displayName = "Spinner";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Badge/Badge.js
var React11 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Badge/badge.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Badge/badge.css";
var badge_default = {
  "badge": "pf-c-badge",
  "modifiers": {
    "read": "pf-m-read",
    "unread": "pf-m-unread"
  },
  "themeDark": "pf-theme-dark"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Badge/Badge.js
var Badge = (_a) => {
  var { isRead = false, className = "", children = "", screenReaderText } = _a, props = __rest(_a, ["isRead", "className", "children", "screenReaderText"]);
  return React11.createElement(
    "span",
    Object.assign({}, props, { className: css(badge_default.badge, isRead ? badge_default.modifiers.read : badge_default.modifiers.unread, className) }),
    children,
    screenReaderText && React11.createElement("span", { className: "pf-screen-reader" }, screenReaderText)
  );
};
Badge.displayName = "Badge";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Button/Button.js
var React12 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Button/button.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Button/button.css";
var button_default = {
  "badge": "pf-c-badge",
  "button": "pf-c-button",
  "buttonCount": "pf-c-button__count",
  "buttonIcon": "pf-c-button__icon",
  "buttonProgress": "pf-c-button__progress",
  "modifiers": {
    "active": "pf-m-active",
    "block": "pf-m-block",
    "small": "pf-m-small",
    "primary": "pf-m-primary",
    "displayLg": "pf-m-display-lg",
    "secondary": "pf-m-secondary",
    "tertiary": "pf-m-tertiary",
    "link": "pf-m-link",
    "unread": "pf-m-unread",
    "inline": "pf-m-inline",
    "danger": "pf-m-danger",
    "warning": "pf-m-warning",
    "control": "pf-m-control",
    "expanded": "pf-m-expanded",
    "plain": "pf-m-plain",
    "disabled": "pf-m-disabled",
    "ariaDisabled": "pf-m-aria-disabled",
    "progress": "pf-m-progress",
    "inProgress": "pf-m-in-progress",
    "start": "pf-m-start",
    "end": "pf-m-end",
    "overpassFont": "pf-m-overpass-font"
  },
  "spinner": "pf-c-spinner",
  "themeDark": "pf-theme-dark"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Button/Button.js
var ButtonVariant;
(function(ButtonVariant2) {
  ButtonVariant2["primary"] = "primary";
  ButtonVariant2["secondary"] = "secondary";
  ButtonVariant2["tertiary"] = "tertiary";
  ButtonVariant2["danger"] = "danger";
  ButtonVariant2["warning"] = "warning";
  ButtonVariant2["link"] = "link";
  ButtonVariant2["plain"] = "plain";
  ButtonVariant2["control"] = "control";
})(ButtonVariant || (ButtonVariant = {}));
var ButtonType;
(function(ButtonType2) {
  ButtonType2["button"] = "button";
  ButtonType2["submit"] = "submit";
  ButtonType2["reset"] = "reset";
})(ButtonType || (ButtonType = {}));
var ButtonBase = (_a) => {
  var { children = null, className = "", component = "button", isActive = false, isBlock = false, isDisabled = false, isAriaDisabled = false, isLoading = null, isDanger = false, spinnerAriaValueText, spinnerAriaLabelledBy, spinnerAriaLabel, isSmall = false, isLarge = false, inoperableEvents = ["onClick", "onKeyPress"], isInline = false, type = ButtonType.button, variant = ButtonVariant.primary, iconPosition = "left", "aria-label": ariaLabel = null, icon = null, ouiaId, ouiaSafe = true, tabIndex = null, innerRef, countOptions } = _a, props = __rest(_a, ["children", "className", "component", "isActive", "isBlock", "isDisabled", "isAriaDisabled", "isLoading", "isDanger", "spinnerAriaValueText", "spinnerAriaLabelledBy", "spinnerAriaLabel", "isSmall", "isLarge", "inoperableEvents", "isInline", "type", "variant", "iconPosition", "aria-label", "icon", "ouiaId", "ouiaSafe", "tabIndex", "innerRef", "countOptions"]);
  const ouiaProps = useOUIAProps(Button.displayName, ouiaId, ouiaSafe, variant);
  const Component19 = component;
  const isButtonElement = Component19 === "button";
  const isInlineSpan = isInline && Component19 === "span";
  const preventedEvents2 = inoperableEvents.reduce((handlers, eventToPrevent) => Object.assign(Object.assign({}, handlers), { [eventToPrevent]: (event) => {
    event.preventDefault();
  } }), {});
  const getDefaultTabIdx = () => {
    if (isDisabled) {
      return isButtonElement ? null : -1;
    } else if (isAriaDisabled) {
      return null;
    } else if (isInlineSpan) {
      return 0;
    }
  };
  return React12.createElement(
    Component19,
    Object.assign({}, props, isAriaDisabled ? preventedEvents2 : null, { "aria-disabled": isDisabled || isAriaDisabled, "aria-label": ariaLabel, className: css(button_default.button, button_default.modifiers[variant], isBlock && button_default.modifiers.block, isDisabled && button_default.modifiers.disabled, isAriaDisabled && button_default.modifiers.ariaDisabled, isActive && button_default.modifiers.active, isInline && variant === ButtonVariant.link && button_default.modifiers.inline, isDanger && (variant === ButtonVariant.secondary || variant === ButtonVariant.link) && button_default.modifiers.danger, isLoading !== null && children !== null && button_default.modifiers.progress, isLoading && button_default.modifiers.inProgress, isSmall && button_default.modifiers.small, isLarge && button_default.modifiers.displayLg, className), disabled: isButtonElement ? isDisabled : null, tabIndex: tabIndex !== null ? tabIndex : getDefaultTabIdx(), type: isButtonElement || isInlineSpan ? type : null, role: isInlineSpan ? "button" : null, ref: innerRef }, ouiaProps),
    isLoading && React12.createElement(
      "span",
      { className: css(button_default.buttonProgress) },
      React12.createElement(Spinner, { size: spinnerSize.md, isInline, "aria-valuetext": spinnerAriaValueText, "aria-label": spinnerAriaLabel, "aria-labelledby": spinnerAriaLabelledBy })
    ),
    variant === ButtonVariant.plain && children === null && icon ? icon : null,
    variant !== ButtonVariant.plain && icon && iconPosition === "left" && React12.createElement("span", { className: css(button_default.buttonIcon, button_default.modifiers.start) }, icon),
    children,
    variant !== ButtonVariant.plain && icon && iconPosition === "right" && React12.createElement("span", { className: css(button_default.buttonIcon, button_default.modifiers.end) }, icon),
    countOptions && React12.createElement(
      "span",
      { className: css(button_default.buttonCount, countOptions.className) },
      React12.createElement(Badge, { isRead: countOptions.isRead }, countOptions.count)
    )
  );
};
var Button = React12.forwardRef((props, ref) => React12.createElement(ButtonBase, Object.assign({ innerRef: ref }, props)));
Button.displayName = "Button";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Tooltip/Tooltip.js
var React15 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Tooltip/tooltip.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Tooltip/tooltip.css";
var tooltip_default = {
  "modifiers": {
    "top": "pf-m-top",
    "topLeft": "pf-m-top-left",
    "topRight": "pf-m-top-right",
    "bottom": "pf-m-bottom",
    "bottomLeft": "pf-m-bottom-left",
    "bottomRight": "pf-m-bottom-right",
    "left": "pf-m-left",
    "leftTop": "pf-m-left-top",
    "leftBottom": "pf-m-left-bottom",
    "right": "pf-m-right",
    "rightTop": "pf-m-right-top",
    "rightBottom": "pf-m-right-bottom",
    "textAlignLeft": "pf-m-text-align-left"
  },
  "themeDark": "pf-theme-dark",
  "tooltip": "pf-c-tooltip",
  "tooltipArrow": "pf-c-tooltip__arrow",
  "tooltipContent": "pf-c-tooltip__content"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Tooltip/TooltipContent.js
var React13 = __toESM(require_react());
var TooltipContent = (_a) => {
  var { className, children, isLeftAligned } = _a, props = __rest(_a, ["className", "children", "isLeftAligned"]);
  return React13.createElement("div", Object.assign({ className: css(tooltip_default.tooltipContent, isLeftAligned && tooltip_default.modifiers.textAlignLeft, className) }, props), children);
};
TooltipContent.displayName = "TooltipContent";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Tooltip/TooltipArrow.js
var React14 = __toESM(require_react());
var TooltipArrow = (_a) => {
  var { className } = _a, props = __rest(_a, ["className"]);
  return React14.createElement("div", Object.assign({ className: css(tooltip_default.tooltipArrow, className) }, props));
};
TooltipArrow.displayName = "TooltipArrow";

// ../../node_modules/.pnpm/@patternfly+react-tokens@4.94.7/node_modules/@patternfly/react-tokens/dist/esm/c_tooltip_MaxWidth.js
var c_tooltip_MaxWidth = {
  "name": "--pf-c-tooltip--MaxWidth",
  "value": "18.75rem",
  "var": "var(--pf-c-tooltip--MaxWidth)"
};
var c_tooltip_MaxWidth_default = c_tooltip_MaxWidth;

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Tooltip/Tooltip.js
var TooltipPosition;
(function(TooltipPosition2) {
  TooltipPosition2["auto"] = "auto";
  TooltipPosition2["top"] = "top";
  TooltipPosition2["bottom"] = "bottom";
  TooltipPosition2["left"] = "left";
  TooltipPosition2["right"] = "right";
  TooltipPosition2["topStart"] = "top-start";
  TooltipPosition2["topEnd"] = "top-end";
  TooltipPosition2["bottomStart"] = "bottom-start";
  TooltipPosition2["bottomEnd"] = "bottom-end";
  TooltipPosition2["leftStart"] = "left-start";
  TooltipPosition2["leftEnd"] = "left-end";
  TooltipPosition2["rightStart"] = "right-start";
  TooltipPosition2["rightEnd"] = "right-end";
})(TooltipPosition || (TooltipPosition = {}));
var pfTooltipIdCounter = 1;
var Tooltip = (_a) => {
  var {
    content: bodyContent,
    position = "top",
    trigger = "mouseenter focus",
    isVisible = false,
    isContentLeftAligned = false,
    enableFlip = true,
    className = "",
    entryDelay = 300,
    exitDelay = 300,
    appendTo = () => document.body,
    zIndex = 9999,
    maxWidth = c_tooltip_MaxWidth_default.value,
    distance = 15,
    aria = "describedby",
    // For every initial starting position, there are 3 escape positions
    flipBehavior = ["top", "right", "bottom", "left", "top", "right", "bottom"],
    id = `pf-tooltip-${pfTooltipIdCounter++}`,
    children,
    animationDuration = 300,
    reference: reference2,
    "aria-live": ariaLive = reference2 ? "polite" : "off",
    boundary,
    isAppLauncher,
    tippyProps,
    removeFindDomNode = false,
    onTooltipHidden = () => {
    }
  } = _a, rest = __rest(_a, ["content", "position", "trigger", "isVisible", "isContentLeftAligned", "enableFlip", "className", "entryDelay", "exitDelay", "appendTo", "zIndex", "maxWidth", "distance", "aria", "flipBehavior", "id", "children", "animationDuration", "reference", "aria-live", "boundary", "isAppLauncher", "tippyProps", "removeFindDomNode", "onTooltipHidden"]);
  if (true) {
    boundary !== void 0 && console.warn("The Tooltip boundary prop has been deprecated. If you want to constrain the popper to a specific element use the appendTo prop instead.");
    isAppLauncher !== void 0 && console.warn("The Tooltip isAppLauncher prop has been deprecated and is no longer used.");
    tippyProps !== void 0 && console.warn("The Tooltip tippyProps prop has been deprecated and is no longer used.");
  }
  const hideOnClick = true;
  const triggerOnMouseenter = trigger.includes("mouseenter");
  const triggerOnFocus = trigger.includes("focus");
  const triggerOnClick = trigger.includes("click");
  const triggerManually = trigger === "manual";
  const [visible, setVisible] = React15.useState(false);
  const [opacity, setOpacity] = React15.useState(0);
  const transitionTimerRef = React15.useRef(null);
  const showTimerRef = React15.useRef(null);
  const hideTimerRef = React15.useRef(null);
  const prevExitDelayRef = React15.useRef();
  const clearTimeouts = (timeoutRefs) => {
    timeoutRefs.forEach((ref) => {
      if (ref.current) {
        clearTimeout(ref.current);
      }
    });
  };
  React15.useEffect(() => () => {
    clearTimeouts([transitionTimerRef, hideTimerRef, showTimerRef]);
  }, []);
  const onDocumentKeyDown = (event) => {
    if (!triggerManually) {
      if (event.key === KeyTypes.Escape && visible) {
        hide2();
      }
    }
  };
  const onTriggerEnter = (event) => {
    if (event.key === KeyTypes.Enter) {
      if (!visible) {
        show();
      } else {
        hide2();
      }
    }
  };
  React15.useEffect(() => {
    if (isVisible) {
      show();
    } else {
      hide2();
    }
  }, [isVisible]);
  React15.useEffect(() => {
    if (prevExitDelayRef.current < exitDelay) {
      clearTimeouts([transitionTimerRef, hideTimerRef]);
      hideTimerRef.current = setTimeout(() => {
        setOpacity(0);
        transitionTimerRef.current = setTimeout(() => {
          setVisible(false);
          onTooltipHidden();
        }, animationDuration);
      }, exitDelay);
    }
    prevExitDelayRef.current = exitDelay;
  }, [exitDelay]);
  const show = () => {
    clearTimeouts([transitionTimerRef, hideTimerRef]);
    showTimerRef.current = setTimeout(() => {
      setVisible(true);
      setOpacity(1);
    }, entryDelay);
  };
  const hide2 = () => {
    clearTimeouts([showTimerRef]);
    hideTimerRef.current = setTimeout(() => {
      setOpacity(0);
      transitionTimerRef.current = setTimeout(() => {
        setVisible(false);
        onTooltipHidden();
      }, animationDuration);
    }, exitDelay);
  };
  const positionModifiers = {
    top: tooltip_default.modifiers.top,
    bottom: tooltip_default.modifiers.bottom,
    left: tooltip_default.modifiers.left,
    right: tooltip_default.modifiers.right,
    "top-start": tooltip_default.modifiers.topLeft,
    "top-end": tooltip_default.modifiers.topRight,
    "bottom-start": tooltip_default.modifiers.bottomLeft,
    "bottom-end": tooltip_default.modifiers.bottomRight,
    "left-start": tooltip_default.modifiers.leftTop,
    "left-end": tooltip_default.modifiers.leftBottom,
    "right-start": tooltip_default.modifiers.rightTop,
    "right-end": tooltip_default.modifiers.rightBottom
  };
  const hasCustomMaxWidth = maxWidth !== c_tooltip_MaxWidth_default.value;
  const content = React15.createElement(
    "div",
    Object.assign({ "aria-live": ariaLive, className: css(tooltip_default.tooltip, className), role: "tooltip", id, style: {
      maxWidth: hasCustomMaxWidth ? maxWidth : null,
      opacity,
      transition: getOpacityTransition(animationDuration)
    } }, rest),
    React15.createElement(TooltipArrow, null),
    React15.createElement(TooltipContent, { isLeftAligned: isContentLeftAligned }, bodyContent)
  );
  const onDocumentClick = (event, triggerElement) => {
    if (hideOnClick === true) {
      if (visible) {
        hide2();
      } else if (event.target === triggerElement) {
        show();
      }
    } else if (hideOnClick === "toggle" && event.target === triggerElement) {
      if (visible) {
        hide2();
      } else {
        show();
      }
    } else if (hideOnClick === false && !visible && event.target === triggerElement) {
      show();
    }
  };
  const addAriaToTrigger = () => {
    if (aria === "describedby" && children && children.props && !children.props["aria-describedby"]) {
      return React15.cloneElement(children, { "aria-describedby": id });
    } else if (aria === "labelledby" && children.props && !children.props["aria-labelledby"]) {
      return React15.cloneElement(children, { "aria-labelledby": id });
    }
    return children;
  };
  return React15.createElement(Popper, { trigger: aria !== "none" && visible ? addAriaToTrigger() : children, reference: reference2, popper: content, popperMatchesTriggerWidth: false, appendTo, isVisible: visible, positionModifiers, distance, placement: position, onMouseEnter: triggerOnMouseenter && show, onMouseLeave: triggerOnMouseenter && hide2, onPopperMouseEnter: triggerOnMouseenter && show, onPopperMouseLeave: triggerOnMouseenter && hide2, onFocus: triggerOnFocus && show, onBlur: triggerOnFocus && hide2, onDocumentClick: triggerOnClick && onDocumentClick, onDocumentKeyDown: triggerManually ? null : onDocumentKeyDown, onTriggerEnter: triggerManually ? null : onTriggerEnter, enableFlip, zIndex, flipBehavior, removeFindDomNode });
};
Tooltip.displayName = "Tooltip";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/dropdownConstants.js
var React16 = __toESM(require_react());
var DropdownPosition;
(function(DropdownPosition2) {
  DropdownPosition2["right"] = "right";
  DropdownPosition2["left"] = "left";
})(DropdownPosition || (DropdownPosition = {}));
var DropdownDirection;
(function(DropdownDirection2) {
  DropdownDirection2["up"] = "up";
  DropdownDirection2["down"] = "down";
})(DropdownDirection || (DropdownDirection = {}));
var DropdownContext = React16.createContext({
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onSelect: (event) => void 0,
  id: "",
  toggleIndicatorClass: "",
  toggleIconClass: "",
  toggleTextClass: "",
  menuClass: "",
  itemClass: "",
  toggleClass: "",
  baseClass: "",
  baseComponent: "div",
  sectionClass: "",
  sectionTitleClass: "",
  sectionComponent: "section",
  disabledClass: "",
  plainTextClass: "",
  menuComponent: "ul"
});
var DropdownArrowContext = React16.createContext({
  keyHandler: null,
  sendRef: null
});

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownMenu.js
var React17 = __toESM(require_react());
var ReactDOM4 = __toESM(require_react_dom());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Dropdown/dropdown.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Dropdown/dropdown.css";
var dropdown_default = {
  "badge": "pf-c-badge",
  "check": "pf-c-check",
  "divider": "pf-c-divider",
  "dropdown": "pf-c-dropdown",
  "dropdownGroup": "pf-c-dropdown__group",
  "dropdownGroupTitle": "pf-c-dropdown__group-title",
  "dropdownMenu": "pf-c-dropdown__menu",
  "dropdownMenuItem": "pf-c-dropdown__menu-item",
  "dropdownMenuItemDescription": "pf-c-dropdown__menu-item-description",
  "dropdownMenuItemIcon": "pf-c-dropdown__menu-item-icon",
  "dropdownMenuItemMain": "pf-c-dropdown__menu-item-main",
  "dropdownToggle": "pf-c-dropdown__toggle",
  "dropdownToggleButton": "pf-c-dropdown__toggle-button",
  "dropdownToggleCheck": "pf-c-dropdown__toggle-check",
  "dropdownToggleIcon": "pf-c-dropdown__toggle-icon",
  "dropdownToggleImage": "pf-c-dropdown__toggle-image",
  "dropdownToggleProgress": "pf-c-dropdown__toggle-progress",
  "dropdownToggleText": "pf-c-dropdown__toggle-text",
  "menu": "pf-c-menu",
  "modifiers": {
    "fullHeight": "pf-m-full-height",
    "expanded": "pf-m-expanded",
    "action": "pf-m-action",
    "disabled": "pf-m-disabled",
    "plain": "pf-m-plain",
    "text": "pf-m-text",
    "splitButton": "pf-m-split-button",
    "primary": "pf-m-primary",
    "inProgress": "pf-m-in-progress",
    "active": "pf-m-active",
    "secondary": "pf-m-secondary",
    "top": "pf-m-top",
    "static": "pf-m-static",
    "alignRight": "pf-m-align-right",
    "alignLeft": "pf-m-align-left",
    "alignRightOnSm": "pf-m-align-right-on-sm",
    "alignLeftOnSm": "pf-m-align-left-on-sm",
    "alignRightOnMd": "pf-m-align-right-on-md",
    "alignLeftOnMd": "pf-m-align-left-on-md",
    "alignRightOnLg": "pf-m-align-right-on-lg",
    "alignLeftOnLg": "pf-m-align-left-on-lg",
    "alignRightOnXl": "pf-m-align-right-on-xl",
    "alignLeftOnXl": "pf-m-align-left-on-xl",
    "alignRightOn_2xl": "pf-m-align-right-on-2xl",
    "alignLeftOn_2xl": "pf-m-align-left-on-2xl",
    "ariaDisabled": "pf-m-aria-disabled",
    "icon": "pf-m-icon",
    "description": "pf-m-description"
  },
  "spinner": "pf-c-spinner",
  "themeDark": "pf-theme-dark"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownMenu.js
var DropdownMenu = class _DropdownMenu extends React17.Component {
  constructor() {
    super(...arguments);
    this.refsCollection = [];
    this.componentWillUnmount = () => {
      document.removeEventListener("keydown", this.onKeyDown);
    };
    this.onKeyDown = (event) => {
      if (!this.props.isOpen || !Array.from(document.activeElement.classList).find((className) => _DropdownMenu.validToggleClasses.concat(this.context.toggleClass).includes(className))) {
        return;
      }
      const refs = this.refsCollection;
      if (event.key === "ArrowDown") {
        const firstFocusTargetCollection = refs.find((ref) => ref && ref[0] && !ref[0].hasAttribute("disabled"));
        _DropdownMenu.focusFirstRef(firstFocusTargetCollection);
        event.stopPropagation();
      } else if (event.key === "ArrowUp") {
        const collectionLength = refs.length;
        const lastFocusTargetCollection = refs.slice(collectionLength - 1, collectionLength);
        const lastFocusTarget = lastFocusTargetCollection && lastFocusTargetCollection[0];
        _DropdownMenu.focusFirstRef(lastFocusTarget);
        event.stopPropagation();
      }
    };
    this.childKeyHandler = (index, innerIndex, position, custom = false) => {
      keyHandler(index, innerIndex, position, this.refsCollection, this.props.isGrouped ? this.refsCollection : React17.Children.toArray(this.props.children), custom);
    };
    this.sendRef = (index, nodes, isDisabled, isSeparator) => {
      this.refsCollection[index] = [];
      nodes.map((node, innerIndex) => {
        if (!node) {
          this.refsCollection[index][innerIndex] = null;
        } else if (!node.getAttribute) {
          this.refsCollection[index][innerIndex] = ReactDOM4.findDOMNode(node);
        } else if (isSeparator) {
          this.refsCollection[index][innerIndex] = null;
        } else {
          this.refsCollection[index][innerIndex] = node;
        }
      });
    };
  }
  componentDidMount() {
    document.addEventListener("keydown", this.onKeyDown);
    const { autoFocus } = this.props;
    if (autoFocus) {
      const focusTargetCollection = this.refsCollection.find((ref) => ref && ref[0] && !ref[0].hasAttribute("disabled"));
      const focusTarget = focusTargetCollection && focusTargetCollection[0];
      if (focusTarget && focusTarget.focus) {
        setTimeout(() => focusTarget.focus());
      }
    }
  }
  shouldComponentUpdate() {
    this.refsCollection = [];
    return true;
  }
  extendChildren() {
    const { children, isGrouped } = this.props;
    if (isGrouped) {
      let index = 0;
      return React17.Children.map(children, (groupedChildren) => {
        const group = groupedChildren;
        const props = {};
        if (group.props && group.props.children) {
          if (Array.isArray(group.props.children)) {
            props.children = React17.Children.map(group.props.children, (option) => React17.cloneElement(option, {
              index: index++
            }));
          } else {
            props.children = React17.cloneElement(group.props.children, {
              index: index++
            });
          }
        }
        return React17.cloneElement(group, props);
      });
    }
    return React17.Children.map(children, (child, index) => React17.cloneElement(child, {
      index
    }));
  }
  render() {
    const _a = this.props, {
      className,
      isOpen,
      position,
      children,
      component,
      isGrouped,
      setMenuComponentRef,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      openedOnEnter,
      alignments
    } = _a, props = __rest(_a, ["className", "isOpen", "position", "children", "component", "isGrouped", "setMenuComponentRef", "openedOnEnter", "alignments"]);
    return React17.createElement(DropdownArrowContext.Provider, { value: {
      keyHandler: this.childKeyHandler,
      sendRef: this.sendRef
    } }, component === "div" ? React17.createElement(DropdownContext.Consumer, null, ({ onSelect, menuClass }) => React17.createElement("div", { className: css(menuClass, position === DropdownPosition.right && dropdown_default.modifiers.alignRight, formatBreakpointMods(alignments, dropdown_default, "align-"), className), hidden: !isOpen, onClick: (event) => onSelect && onSelect(event), ref: setMenuComponentRef }, children)) : isGrouped && React17.createElement(DropdownContext.Consumer, null, ({ menuClass, menuComponent }) => {
      const MenuComponent = menuComponent || "div";
      return React17.createElement(MenuComponent, Object.assign({}, props, { className: css(menuClass, position === DropdownPosition.right && dropdown_default.modifiers.alignRight, formatBreakpointMods(alignments, dropdown_default, "align-"), className), hidden: !isOpen, role: "menu", ref: setMenuComponentRef }), this.extendChildren());
    }) || React17.createElement(DropdownContext.Consumer, null, ({ menuClass, menuComponent }) => {
      const MenuComponent = menuComponent || component;
      return React17.createElement(MenuComponent, Object.assign({}, props, { className: css(menuClass, position === DropdownPosition.right && dropdown_default.modifiers.alignRight, formatBreakpointMods(alignments, dropdown_default, "align-"), className), hidden: !isOpen, role: "menu", ref: setMenuComponentRef }), this.extendChildren());
    }));
  }
};
DropdownMenu.displayName = "DropdownMenu";
DropdownMenu.defaultProps = {
  className: "",
  isOpen: true,
  openedOnEnter: false,
  autoFocus: true,
  position: DropdownPosition.left,
  component: "ul",
  isGrouped: false,
  setMenuComponentRef: null
};
DropdownMenu.validToggleClasses = [dropdown_default.dropdownToggle, dropdown_default.dropdownToggleButton];
DropdownMenu.focusFirstRef = (refCollection) => {
  if (refCollection && refCollection[0] && refCollection[0].focus) {
    setTimeout(() => refCollection[0].focus());
  }
};
DropdownMenu.contextType = DropdownContext;

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownWithContext.js
var React18 = __toESM(require_react());
var DropdownWithContext = class _DropdownWithContext extends React18.Component {
  constructor(props) {
    super(props);
    this.openedOnEnter = false;
    this.baseComponentRef = React18.createRef();
    this.menuComponentRef = React18.createRef();
    this.onEnter = () => {
      this.openedOnEnter = true;
    };
    this.setMenuComponentRef = (element) => {
      this.menuComponentRef = element;
    };
    this.getMenuComponentRef = () => this.menuComponentRef;
    if (props.dropdownItems && props.dropdownItems.length > 0 && props.children) {
      console.error("Children and dropdownItems props have been provided. Only the dropdownItems prop items will be rendered");
    }
  }
  componentDidUpdate() {
    if (!this.props.isOpen) {
      this.openedOnEnter = false;
    }
  }
  render() {
    const _a = this.props, {
      children,
      className,
      direction,
      dropdownItems,
      isOpen,
      isPlain,
      isText,
      isGrouped,
      isFullHeight,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onSelect,
      position,
      toggle,
      autoFocus,
      menuAppendTo,
      isFlipEnabled,
      removeFindDomNode,
      zIndex
    } = _a, props = __rest(_a, ["children", "className", "direction", "dropdownItems", "isOpen", "isPlain", "isText", "isGrouped", "isFullHeight", "onSelect", "position", "toggle", "autoFocus", "menuAppendTo", "isFlipEnabled", "removeFindDomNode", "zIndex"]);
    const id = toggle.props.id || `pf-dropdown-toggle-id-${_DropdownWithContext.currentId++}`;
    let component;
    let renderedContent;
    let ariaHasPopup = false;
    if (dropdownItems && dropdownItems.length > 0) {
      component = "ul";
      renderedContent = dropdownItems;
      ariaHasPopup = true;
    } else {
      component = "div";
      renderedContent = React18.Children.toArray(children);
    }
    const openedOnEnter = this.openedOnEnter;
    const isStatic = isFlipEnabled && menuAppendTo !== "inline";
    return React18.createElement(DropdownContext.Consumer, null, ({ baseClass, baseComponent, id: contextId, ouiaId, ouiaComponentType, ouiaSafe, alignments }) => {
      const BaseComponent = baseComponent;
      const menuContainer = React18.createElement(DropdownMenu, { className: css(isStatic && dropdown_default.modifiers.static), setMenuComponentRef: this.setMenuComponentRef, component, isOpen, position, "aria-labelledby": contextId ? `${contextId}-toggle` : id, isGrouped, autoFocus: openedOnEnter && autoFocus, alignments }, renderedContent);
      const popperContainer = React18.createElement("div", { className: css(baseClass, direction === DropdownDirection.up && dropdown_default.modifiers.top, position === DropdownPosition.right && dropdown_default.modifiers.alignRight, isOpen && dropdown_default.modifiers.expanded, className) }, isOpen && menuContainer);
      const mainContainer = React18.createElement(
        BaseComponent,
        Object.assign({}, props, { className: css(baseClass, direction === DropdownDirection.up && dropdown_default.modifiers.top, position === DropdownPosition.right && dropdown_default.modifiers.alignRight, isOpen && dropdown_default.modifiers.expanded, isFullHeight && dropdown_default.modifiers.fullHeight, className), ref: this.baseComponentRef }, getOUIAProps(ouiaComponentType, ouiaId, ouiaSafe)),
        React18.Children.map(toggle, (oneToggle) => React18.cloneElement(oneToggle, {
          parentRef: this.baseComponentRef,
          getMenuRef: this.getMenuComponentRef,
          isOpen,
          id,
          isPlain,
          isText,
          "aria-haspopup": ariaHasPopup,
          onEnter: () => {
            this.onEnter();
            oneToggle.props.onEnter && oneToggle.props.onEnter();
          }
        })),
        menuAppendTo === "inline" && isOpen && menuContainer
      );
      const getParentElement = () => {
        if (this.baseComponentRef && this.baseComponentRef.current) {
          return this.baseComponentRef.current.parentElement;
        }
        return null;
      };
      return menuAppendTo === "inline" ? mainContainer : React18.createElement(Popper, { trigger: mainContainer, popper: popperContainer, direction, position, appendTo: menuAppendTo === "parent" ? getParentElement() : menuAppendTo, isVisible: isOpen, removeFindDomNode, zIndex, popperMatchesTriggerWidth: false });
    });
  }
};
DropdownWithContext.displayName = "DropdownWithContext";
DropdownWithContext.currentId = 0;
DropdownWithContext.defaultProps = {
  className: "",
  dropdownItems: [],
  isOpen: false,
  isPlain: false,
  isText: false,
  isGrouped: false,
  position: DropdownPosition.left,
  direction: DropdownDirection.down,
  onSelect: () => void 0,
  autoFocus: true,
  menuAppendTo: "inline",
  isFlipEnabled: true
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/Dropdown.js
var React19 = __toESM(require_react());
var Dropdown = (_a) => {
  var {
    onSelect,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref,
    // Types of Ref are different for React.FunctionComponent vs React.Component
    ouiaId,
    ouiaSafe,
    alignments,
    contextProps,
    menuAppendTo = "inline",
    isFlipEnabled = true,
    removeFindDomNode = false,
    zIndex = 9999
  } = _a, props = __rest(_a, ["onSelect", "ref", "ouiaId", "ouiaSafe", "alignments", "contextProps", "menuAppendTo", "isFlipEnabled", "removeFindDomNode", "zIndex"]);
  return React19.createElement(
    DropdownContext.Provider,
    { value: Object.assign({ onSelect: (event) => onSelect && onSelect(event), toggleTextClass: dropdown_default.dropdownToggleText, toggleIconClass: dropdown_default.dropdownToggleImage, toggleIndicatorClass: dropdown_default.dropdownToggleIcon, menuClass: dropdown_default.dropdownMenu, itemClass: dropdown_default.dropdownMenuItem, toggleClass: dropdown_default.dropdownToggle, baseClass: dropdown_default.dropdown, baseComponent: "div", sectionClass: dropdown_default.dropdownGroup, sectionTitleClass: dropdown_default.dropdownGroupTitle, sectionComponent: "section", disabledClass: dropdown_default.modifiers.disabled, plainTextClass: dropdown_default.modifiers.text, ouiaId: useOUIAId(Dropdown.displayName, ouiaId), ouiaSafe, ouiaComponentType: Dropdown.displayName, alignments }, contextProps) },
    React19.createElement(DropdownWithContext, Object.assign({ menuAppendTo, isFlipEnabled, removeFindDomNode, zIndex }, props))
  );
};
Dropdown.displayName = "Dropdown";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownGroup.js
var React20 = __toESM(require_react());
var DropdownGroup = (_a) => {
  var { children = null, className = "", label = "" } = _a, props = __rest(_a, ["children", "className", "label"]);
  return React20.createElement(DropdownContext.Consumer, null, ({ sectionClass, sectionTitleClass, sectionComponent }) => {
    const SectionComponent = sectionComponent;
    return React20.createElement(
      SectionComponent,
      Object.assign({ className: css(sectionClass, className) }, props),
      label && React20.createElement("h1", { className: css(sectionTitleClass), "aria-hidden": true }, label),
      React20.createElement("ul", { role: "none" }, children)
    );
  });
};
DropdownGroup.displayName = "DropdownGroup";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownItem.js
var React22 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/InternalDropdownItem.js
var React21 = __toESM(require_react());
var InternalDropdownItem = class extends React21.Component {
  constructor() {
    super(...arguments);
    this.ref = React21.createRef();
    this.additionalRef = React21.createRef();
    this.getInnerNode = (node) => node && node.childNodes && node.childNodes.length ? node.childNodes[0] : node;
    this.onKeyDown = (event) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const innerIndex = event.target === this.ref.current ? 0 : 1;
      if (!this.props.customChild) {
        event.preventDefault();
      }
      if (event.key === "ArrowUp") {
        (_b = (_a = this.props.context) === null || _a === void 0 ? void 0 : _a.keyHandler) === null || _b === void 0 ? void 0 : _b.call(_a, this.props.index, innerIndex, KEYHANDLER_DIRECTION.UP);
        event.stopPropagation();
      } else if (event.key === "ArrowDown") {
        (_d = (_c = this.props.context) === null || _c === void 0 ? void 0 : _c.keyHandler) === null || _d === void 0 ? void 0 : _d.call(_c, this.props.index, innerIndex, KEYHANDLER_DIRECTION.DOWN);
        event.stopPropagation();
      } else if (event.key === "ArrowRight") {
        (_f = (_e = this.props.context) === null || _e === void 0 ? void 0 : _e.keyHandler) === null || _f === void 0 ? void 0 : _f.call(_e, this.props.index, innerIndex, KEYHANDLER_DIRECTION.RIGHT);
        event.stopPropagation();
      } else if (event.key === "ArrowLeft") {
        (_h = (_g = this.props.context) === null || _g === void 0 ? void 0 : _g.keyHandler) === null || _h === void 0 ? void 0 : _h.call(_g, this.props.index, innerIndex, KEYHANDLER_DIRECTION.LEFT);
        event.stopPropagation();
      } else if (event.key === "Enter" || event.key === " ") {
        event.target.click();
        this.props.enterTriggersArrowDown && ((_k = (_j = this.props.context) === null || _j === void 0 ? void 0 : _j.keyHandler) === null || _k === void 0 ? void 0 : _k.call(_j, this.props.index, innerIndex, KEYHANDLER_DIRECTION.DOWN));
      }
    };
    this.componentRef = (element) => {
      this.ref.current = element;
      const { component } = this.props;
      const ref = component.ref;
      if (ref) {
        if (typeof ref === "function") {
          ref(element);
        } else {
          ref.current = element;
        }
      }
    };
  }
  componentDidMount() {
    var _a;
    const { context, index, isDisabled, role, customChild, autoFocus } = this.props;
    const customRef = customChild ? this.getInnerNode(this.ref.current) : this.ref.current;
    (_a = context === null || context === void 0 ? void 0 : context.sendRef) === null || _a === void 0 ? void 0 : _a.call(context, index, [customRef, customChild ? customRef : this.additionalRef.current], isDisabled, role === "separator");
    autoFocus && setTimeout(() => customRef.focus());
  }
  componentDidUpdate() {
    var _a;
    const { context, index, isDisabled, role, customChild } = this.props;
    const customRef = customChild ? this.getInnerNode(this.ref.current) : this.ref.current;
    (_a = context === null || context === void 0 ? void 0 : context.sendRef) === null || _a === void 0 ? void 0 : _a.call(context, index, [customRef, customChild ? customRef : this.additionalRef.current], isDisabled, role === "separator");
  }
  extendAdditionalChildRef() {
    const { additionalChild } = this.props;
    return React21.cloneElement(additionalChild, {
      ref: this.additionalRef
    });
  }
  render() {
    const _a = this.props, { className, children, context, onClick, component, role, isDisabled, isAriaDisabled, isPlainText, index, href, tooltip, tooltipProps, id, componentID, listItemClassName, additionalChild, customChild, enterTriggersArrowDown, icon, autoFocus, styleChildren, description, inoperableEvents } = _a, additionalProps = __rest(_a, ["className", "children", "context", "onClick", "component", "role", "isDisabled", "isAriaDisabled", "isPlainText", "index", "href", "tooltip", "tooltipProps", "id", "componentID", "listItemClassName", "additionalChild", "customChild", "enterTriggersArrowDown", "icon", "autoFocus", "styleChildren", "description", "inoperableEvents"]);
    let classes = css(icon && dropdown_default.modifiers.icon, isAriaDisabled && dropdown_default.modifiers.ariaDisabled, className);
    if (component === "a") {
      additionalProps["aria-disabled"] = isDisabled || isAriaDisabled;
    } else if (component === "button") {
      additionalProps["aria-disabled"] = isDisabled || isAriaDisabled;
      additionalProps.type = additionalProps.type || "button";
    }
    const renderWithTooltip = (childNode) => tooltip ? React21.createElement(Tooltip, Object.assign({ content: tooltip }, tooltipProps), childNode) : childNode;
    const renderClonedComponent = (element) => React21.cloneElement(element, Object.assign(Object.assign({}, styleChildren && {
      className: css(element.props.className, classes)
    }), this.props.role !== "separator" && { role, ref: this.componentRef }));
    const renderDefaultComponent = (tag) => {
      const Component19 = tag;
      const componentContent = description ? React21.createElement(
        React21.Fragment,
        null,
        React21.createElement(
          "div",
          { className: dropdown_default.dropdownMenuItemMain },
          icon && React21.createElement("span", { className: css(dropdown_default.dropdownMenuItemIcon) }, icon),
          children
        ),
        React21.createElement("div", { className: dropdown_default.dropdownMenuItemDescription }, description)
      ) : React21.createElement(
        React21.Fragment,
        null,
        icon && React21.createElement("span", { className: css(dropdown_default.dropdownMenuItemIcon) }, icon),
        children
      );
      return React21.createElement(Component19, Object.assign({}, additionalProps, isDisabled || isAriaDisabled ? preventedEvents(inoperableEvents) : null, { href, ref: this.ref, className: classes, id: componentID, role }), componentContent);
    };
    return React21.createElement(DropdownContext.Consumer, null, ({ onSelect, itemClass, disabledClass, plainTextClass }) => {
      if (this.props.role !== "separator") {
        classes = css(classes, isDisabled && disabledClass, isPlainText && plainTextClass, itemClass, description && dropdown_default.modifiers.description);
      }
      if (customChild) {
        return React21.cloneElement(customChild, {
          ref: this.ref,
          onKeyDown: this.onKeyDown
        });
      }
      return React21.createElement(
        "li",
        Object.assign({}, listItemClassName && { className: listItemClassName }, { role: "none", onKeyDown: this.onKeyDown, onClick: (event) => {
          if (!isDisabled && !isAriaDisabled) {
            onClick === null || onClick === void 0 ? void 0 : onClick(event);
            onSelect === null || onSelect === void 0 ? void 0 : onSelect(event);
          }
        }, id }),
        renderWithTooltip(React21.isValidElement(component) ? renderClonedComponent(component) : renderDefaultComponent(component)),
        additionalChild && this.extendAdditionalChildRef()
      );
    });
  }
};
InternalDropdownItem.displayName = "InternalDropdownItem";
InternalDropdownItem.defaultProps = {
  className: "",
  component: "a",
  role: "none",
  isDisabled: false,
  isPlainText: false,
  tooltipProps: {},
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onClick: (event) => void 0,
  index: -1,
  context: {
    keyHandler: () => {
    },
    sendRef: () => {
    }
  },
  enterTriggersArrowDown: false,
  icon: null,
  styleChildren: true,
  description: null,
  inoperableEvents: ["onClick", "onKeyPress"]
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownItem.js
var DropdownItem = (_a) => {
  var {
    children,
    className,
    component = "a",
    isDisabled = false,
    isAriaDisabled = false,
    isPlainText = false,
    href,
    tooltip,
    tooltipProps = {},
    listItemClassName,
    onClick,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref,
    // Types of Ref are different for React.FunctionComponent vs React.Component
    additionalChild,
    customChild,
    tabIndex = -1,
    icon = null,
    autoFocus,
    description = null,
    styleChildren,
    ouiaId,
    ouiaSafe
  } = _a, props = __rest(_a, ["children", "className", "component", "isDisabled", "isAriaDisabled", "isPlainText", "href", "tooltip", "tooltipProps", "listItemClassName", "onClick", "ref", "additionalChild", "customChild", "tabIndex", "icon", "autoFocus", "description", "styleChildren", "ouiaId", "ouiaSafe"]);
  const ouiaProps = useOUIAProps(DropdownItem.displayName, ouiaId, ouiaSafe);
  return React22.createElement(DropdownArrowContext.Consumer, null, (context) => React22.createElement(InternalDropdownItem, Object.assign({ context, role: "menuitem", tabIndex, className, component, isDisabled, isAriaDisabled, isPlainText, href, tooltip, tooltipProps, listItemClassName, onClick, additionalChild, customChild, icon, autoFocus, styleChildren, description }, ouiaProps, props), children));
};
DropdownItem.displayName = "DropdownItem";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Divider/Divider.js
var React23 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Divider/divider.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Divider/divider.css";
var divider_default = {
  "divider": "pf-c-divider",
  "modifiers": {
    "hidden": "pf-m-hidden",
    "hiddenOnSm": "pf-m-hidden-on-sm",
    "visibleOnSm": "pf-m-visible-on-sm",
    "hiddenOnMd": "pf-m-hidden-on-md",
    "visibleOnMd": "pf-m-visible-on-md",
    "hiddenOnLg": "pf-m-hidden-on-lg",
    "visibleOnLg": "pf-m-visible-on-lg",
    "hiddenOnXl": "pf-m-hidden-on-xl",
    "visibleOnXl": "pf-m-visible-on-xl",
    "hiddenOn_2xl": "pf-m-hidden-on-2xl",
    "visibleOn_2xl": "pf-m-visible-on-2xl",
    "vertical": "pf-m-vertical",
    "insetNone": "pf-m-inset-none",
    "insetXs": "pf-m-inset-xs",
    "insetSm": "pf-m-inset-sm",
    "insetMd": "pf-m-inset-md",
    "insetLg": "pf-m-inset-lg",
    "insetXl": "pf-m-inset-xl",
    "inset_2xl": "pf-m-inset-2xl",
    "inset_3xl": "pf-m-inset-3xl",
    "horizontalOnSm": "pf-m-horizontal-on-sm",
    "verticalOnSm": "pf-m-vertical-on-sm",
    "insetNoneOnSm": "pf-m-inset-none-on-sm",
    "insetXsOnSm": "pf-m-inset-xs-on-sm",
    "insetSmOnSm": "pf-m-inset-sm-on-sm",
    "insetMdOnSm": "pf-m-inset-md-on-sm",
    "insetLgOnSm": "pf-m-inset-lg-on-sm",
    "insetXlOnSm": "pf-m-inset-xl-on-sm",
    "inset_2xlOnSm": "pf-m-inset-2xl-on-sm",
    "inset_3xlOnSm": "pf-m-inset-3xl-on-sm",
    "horizontalOnMd": "pf-m-horizontal-on-md",
    "verticalOnMd": "pf-m-vertical-on-md",
    "insetNoneOnMd": "pf-m-inset-none-on-md",
    "insetXsOnMd": "pf-m-inset-xs-on-md",
    "insetSmOnMd": "pf-m-inset-sm-on-md",
    "insetMdOnMd": "pf-m-inset-md-on-md",
    "insetLgOnMd": "pf-m-inset-lg-on-md",
    "insetXlOnMd": "pf-m-inset-xl-on-md",
    "inset_2xlOnMd": "pf-m-inset-2xl-on-md",
    "inset_3xlOnMd": "pf-m-inset-3xl-on-md",
    "horizontalOnLg": "pf-m-horizontal-on-lg",
    "verticalOnLg": "pf-m-vertical-on-lg",
    "insetNoneOnLg": "pf-m-inset-none-on-lg",
    "insetXsOnLg": "pf-m-inset-xs-on-lg",
    "insetSmOnLg": "pf-m-inset-sm-on-lg",
    "insetMdOnLg": "pf-m-inset-md-on-lg",
    "insetLgOnLg": "pf-m-inset-lg-on-lg",
    "insetXlOnLg": "pf-m-inset-xl-on-lg",
    "inset_2xlOnLg": "pf-m-inset-2xl-on-lg",
    "inset_3xlOnLg": "pf-m-inset-3xl-on-lg",
    "horizontalOnXl": "pf-m-horizontal-on-xl",
    "verticalOnXl": "pf-m-vertical-on-xl",
    "insetNoneOnXl": "pf-m-inset-none-on-xl",
    "insetXsOnXl": "pf-m-inset-xs-on-xl",
    "insetSmOnXl": "pf-m-inset-sm-on-xl",
    "insetMdOnXl": "pf-m-inset-md-on-xl",
    "insetLgOnXl": "pf-m-inset-lg-on-xl",
    "insetXlOnXl": "pf-m-inset-xl-on-xl",
    "inset_2xlOnXl": "pf-m-inset-2xl-on-xl",
    "inset_3xlOnXl": "pf-m-inset-3xl-on-xl",
    "horizontalOn_2xl": "pf-m-horizontal-on-2xl",
    "verticalOn_2xl": "pf-m-vertical-on-2xl",
    "insetNoneOn_2xl": "pf-m-inset-none-on-2xl",
    "insetXsOn_2xl": "pf-m-inset-xs-on-2xl",
    "insetSmOn_2xl": "pf-m-inset-sm-on-2xl",
    "insetMdOn_2xl": "pf-m-inset-md-on-2xl",
    "insetLgOn_2xl": "pf-m-inset-lg-on-2xl",
    "insetXlOn_2xl": "pf-m-inset-xl-on-2xl",
    "inset_2xlOn_2xl": "pf-m-inset-2xl-on-2xl",
    "inset_3xlOn_2xl": "pf-m-inset-3xl-on-2xl"
  }
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Divider/Divider.js
var DividerVariant;
(function(DividerVariant2) {
  DividerVariant2["hr"] = "hr";
  DividerVariant2["li"] = "li";
  DividerVariant2["div"] = "div";
})(DividerVariant || (DividerVariant = {}));
var Divider = (_a) => {
  var { className, component = DividerVariant.hr, isVertical = false, inset, orientation } = _a, props = __rest(_a, ["className", "component", "isVertical", "inset", "orientation"]);
  const Component19 = component;
  return React23.createElement(Component19, Object.assign({ className: css(divider_default.divider, isVertical && divider_default.modifiers.vertical, formatBreakpointMods(inset, divider_default), formatBreakpointMods(orientation, divider_default), className) }, component !== "hr" && { role: "separator" }, props));
};
Divider.displayName = "Divider";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownSeparator.js
var React24 = __toESM(require_react());
var DropdownSeparator = (_a) => {
  var {
    className = "",
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref,
    // Types of Ref are different for React.FunctionComponent vs React.Component
    ouiaId,
    ouiaSafe
  } = _a, props = __rest(_a, ["className", "ref", "ouiaId", "ouiaSafe"]);
  const ouiaProps = useOUIAProps(DropdownSeparator.displayName, ouiaId, ouiaSafe);
  return React24.createElement(DropdownArrowContext.Consumer, null, (context) => React24.createElement(InternalDropdownItem, Object.assign({}, props, { context, component: React24.createElement(Divider, { component: DividerVariant.div }), className, role: "separator" }, ouiaProps)));
};
DropdownSeparator.displayName = "DropdownSeparator";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/BadgeToggle.js
var React26 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/Toggle.js
var React25 = __toESM(require_react());
var buttonVariantStyles = {
  default: "",
  primary: dropdown_default.modifiers.primary,
  secondary: dropdown_default.modifiers.secondary
};
var Toggle = class extends React25.Component {
  constructor() {
    super(...arguments);
    this.buttonRef = React25.createRef();
    this.componentDidMount = () => {
      document.addEventListener("click", this.onDocClick);
      document.addEventListener("touchstart", this.onDocClick);
      document.addEventListener("keydown", this.onEscPress);
    };
    this.componentWillUnmount = () => {
      document.removeEventListener("click", this.onDocClick);
      document.removeEventListener("touchstart", this.onDocClick);
      document.removeEventListener("keydown", this.onEscPress);
    };
    this.onDocClick = (event) => {
      const { isOpen, parentRef, onToggle, getMenuRef } = this.props;
      const menuRef = getMenuRef && getMenuRef();
      const clickedOnToggle = parentRef && parentRef.current && parentRef.current.contains(event.target);
      const clickedWithinMenu = menuRef && menuRef.contains && menuRef.contains(event.target);
      if (isOpen && !(clickedOnToggle || clickedWithinMenu)) {
        onToggle === null || onToggle === void 0 ? void 0 : onToggle(false, event);
      }
    };
    this.onEscPress = (event) => {
      var _a, _b, _c;
      const { parentRef, getMenuRef } = this.props;
      const menuRef = getMenuRef && getMenuRef();
      const escFromToggle = parentRef && parentRef.current && parentRef.current.contains(event.target);
      const escFromWithinMenu = menuRef && menuRef.contains && menuRef.contains(event.target);
      if (this.props.isOpen && (event.key === KeyTypes.Escape || event.key === "Tab") && (escFromToggle || escFromWithinMenu)) {
        (_b = (_a = this.props).onToggle) === null || _b === void 0 ? void 0 : _b.call(_a, false, event);
        (_c = this.buttonRef.current) === null || _c === void 0 ? void 0 : _c.focus();
      }
    };
    this.onKeyDown = (event) => {
      var _a, _b, _c, _d, _e, _f;
      if (event.key === "Tab" && !this.props.isOpen) {
        return;
      }
      if ((event.key === "Tab" || event.key === "Enter" || event.key === " ") && this.props.isOpen) {
        if (!this.props.bubbleEvent) {
          event.stopPropagation();
        }
        event.preventDefault();
        (_b = (_a = this.props).onToggle) === null || _b === void 0 ? void 0 : _b.call(_a, !this.props.isOpen, event);
      } else if ((event.key === "Enter" || event.key === " ") && !this.props.isOpen) {
        if (!this.props.bubbleEvent) {
          event.stopPropagation();
        }
        event.preventDefault();
        (_d = (_c = this.props).onToggle) === null || _d === void 0 ? void 0 : _d.call(_c, !this.props.isOpen, event);
        (_f = (_e = this.props).onEnter) === null || _f === void 0 ? void 0 : _f.call(_e);
      }
    };
  }
  render() {
    const _a = this.props, {
      className,
      children,
      isOpen,
      isDisabled,
      isPlain,
      isText,
      isPrimary,
      isSplitButton,
      toggleVariant,
      onToggle,
      "aria-haspopup": ariaHasPopup,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      isActive,
      bubbleEvent,
      onEnter,
      parentRef,
      getMenuRef,
      /* eslint-enable @typescript-eslint/no-unused-vars */
      id,
      type
    } = _a, props = __rest(_a, ["className", "children", "isOpen", "isDisabled", "isPlain", "isText", "isPrimary", "isSplitButton", "toggleVariant", "onToggle", "aria-haspopup", "isActive", "bubbleEvent", "onEnter", "parentRef", "getMenuRef", "id", "type"]);
    return React25.createElement(DropdownContext.Consumer, null, ({ toggleClass }) => React25.createElement("button", Object.assign({}, props, { id, ref: this.buttonRef, className: css(isSplitButton ? dropdown_default.dropdownToggleButton : toggleClass || dropdown_default.dropdownToggle, isActive && dropdown_default.modifiers.active, isPlain && dropdown_default.modifiers.plain, isText && dropdown_default.modifiers.text, isPrimary && dropdown_default.modifiers.primary, toggleVariant && buttonVariantStyles[toggleVariant], className), type: type || "button", onClick: (event) => onToggle === null || onToggle === void 0 ? void 0 : onToggle(!isOpen, event), "aria-expanded": isOpen, "aria-haspopup": ariaHasPopup, onKeyDown: (event) => this.onKeyDown(event), disabled: isDisabled }), children));
  }
};
Toggle.displayName = "Toggle";
Toggle.defaultProps = {
  className: "",
  isOpen: false,
  isActive: false,
  isDisabled: false,
  isPlain: false,
  isText: false,
  isPrimary: false,
  isSplitButton: false,
  onToggle: () => {
  },
  onEnter: () => {
  },
  bubbleEvent: false
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/BadgeToggle.js
var BadgeToggle = (_a) => {
  var {
    id = "",
    children = null,
    badgeProps = { isRead: true },
    className = "",
    isOpen = false,
    "aria-label": ariaLabel = "Actions",
    parentRef = null,
    getMenuRef = null,
    isActive = false,
    isPlain = null,
    isDisabled = false,
    bubbleEvent = false,
    onToggle = () => void 0,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref
  } = _a, props = __rest(_a, ["id", "children", "badgeProps", "className", "isOpen", "aria-label", "parentRef", "getMenuRef", "isActive", "isPlain", "isDisabled", "bubbleEvent", "onToggle", "ref"]);
  return React26.createElement(
    Toggle,
    Object.assign({ id, className, isOpen, "aria-label": ariaLabel, parentRef, getMenuRef, isActive, isPlain: isPlain || true, isDisabled, onToggle, bubbleEvent }, props),
    React26.createElement(
      Badge,
      Object.assign({}, badgeProps),
      children,
      React26.createElement(
        "span",
        { className: css(dropdown_default.dropdownToggleIcon) },
        React26.createElement(caret_down_icon_default, null)
      )
    )
  );
};
BadgeToggle.displayName = "BadgeToggle";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/KebabToggle.js
var React27 = __toESM(require_react());
var KebabToggle = (_a) => {
  var {
    id = "",
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    children = null,
    className = "",
    isOpen = false,
    "aria-label": ariaLabel = "Actions",
    parentRef = null,
    getMenuRef = null,
    isActive = false,
    isPlain = false,
    isDisabled = false,
    bubbleEvent = false,
    onToggle = () => void 0,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref
  } = _a, props = __rest(_a, ["id", "children", "className", "isOpen", "aria-label", "parentRef", "getMenuRef", "isActive", "isPlain", "isDisabled", "bubbleEvent", "onToggle", "ref"]);
  return React27.createElement(
    Toggle,
    Object.assign({ id, className, isOpen, "aria-label": ariaLabel, parentRef, getMenuRef, isActive, isPlain, isDisabled, onToggle, bubbleEvent }, props),
    React27.createElement(ellipsis_v_icon_default, null)
  );
};
KebabToggle.displayName = "KebabToggle";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownToggle.js
var React28 = __toESM(require_react());
var DropdownToggle = (_a) => {
  var {
    id = "",
    children = null,
    className = "",
    isOpen = false,
    parentRef = null,
    getMenuRef = null,
    isDisabled = false,
    isPlain = false,
    isText = false,
    isPrimary = false,
    toggleVariant = "default",
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    isActive = false,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onToggle = (_isOpen) => void 0,
    icon = null,
    toggleIndicator: ToggleIndicator = caret_down_icon_default,
    splitButtonItems,
    splitButtonVariant = "checkbox",
    "aria-haspopup": ariaHasPopup,
    ouiaId,
    ouiaSafe,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref
  } = _a, props = __rest(_a, ["id", "children", "className", "isOpen", "parentRef", "getMenuRef", "isDisabled", "isPlain", "isText", "isPrimary", "toggleVariant", "isActive", "onToggle", "icon", "toggleIndicator", "splitButtonItems", "splitButtonVariant", "aria-haspopup", "ouiaId", "ouiaSafe", "ref"]);
  const ouiaProps = useOUIAProps(DropdownToggle.displayName, ouiaId, ouiaSafe);
  const toggle = React28.createElement(DropdownContext.Consumer, null, ({ toggleTextClass, toggleIndicatorClass, toggleIconClass }) => React28.createElement(
    Toggle,
    Object.assign({}, props, { id, className, isOpen, parentRef, getMenuRef, isActive, isDisabled, isPlain, isText, isPrimary, toggleVariant, onToggle, "aria-haspopup": ariaHasPopup }, ouiaProps, splitButtonItems && { isSplitButton: true, "aria-label": props["aria-label"] || "Select" }),
    icon && React28.createElement("span", { className: css(toggleIconClass) }, icon),
    children && React28.createElement("span", { className: ToggleIndicator && css(toggleTextClass) }, children),
    ToggleIndicator && React28.createElement(
      "span",
      { className: css(!splitButtonItems && toggleIndicatorClass) },
      React28.createElement(ToggleIndicator, null)
    )
  ));
  if (splitButtonItems) {
    return React28.createElement(
      "div",
      { className: css(dropdown_default.dropdownToggle, dropdown_default.modifiers.splitButton, splitButtonVariant === "action" && dropdown_default.modifiers.action, (toggleVariant === "primary" || isPrimary) && splitButtonVariant === "action" && dropdown_default.modifiers.primary, toggleVariant === "secondary" && splitButtonVariant === "action" && dropdown_default.modifiers.secondary, isDisabled && dropdown_default.modifiers.disabled) },
      splitButtonItems,
      toggle
    );
  }
  return toggle;
};
DropdownToggle.displayName = "DropdownToggle";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownToggleCheckbox.js
var React29 = __toESM(require_react());
var DropdownToggleCheckbox = class _DropdownToggleCheckbox extends React29.Component {
  constructor(props) {
    super(props);
    this.handleChange = (event) => {
      var _a, _b;
      (_b = (_a = this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, event.target.checked, event);
    };
    this.calculateChecked = () => {
      const { isChecked, checked } = this.props;
      if (isChecked === null) {
        return false;
      } else if (isChecked !== void 0) {
        return isChecked;
      }
      return checked;
    };
    this.state = {
      ouiaStateId: getDefaultOUIAId(_DropdownToggleCheckbox.displayName)
    };
  }
  render() {
    const _a = this.props, {
      className,
      isValid,
      isDisabled,
      isChecked,
      isInProgress = false,
      defaultProgressAriaLabel,
      defaultProgressAriaValueText = "Loading...",
      children,
      ouiaId,
      ouiaSafe,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      onChange,
      checked
    } = _a, props = __rest(_a, ["className", "isValid", "isDisabled", "isChecked", "isInProgress", "defaultProgressAriaLabel", "defaultProgressAriaValueText", "children", "ouiaId", "ouiaSafe", "onChange", "checked"]);
    const spinner = React29.createElement(Spinner, { diameter: "1em", isSVG: true, "aria-valuetext": defaultProgressAriaValueText, "aria-live": "polite", "aria-label": defaultProgressAriaLabel });
    const text = children && React29.createElement("span", { className: css(dropdown_default.dropdownToggleText, className), "aria-hidden": "true", id: `${props.id}-text` }, children);
    return React29.createElement(
      "label",
      { className: css(dropdown_default.dropdownToggleCheck, isInProgress && dropdown_default.modifiers.inProgress, className), htmlFor: props.id },
      React29.createElement("input", Object.assign({}, props, this.calculateChecked() !== void 0 && { onChange: this.handleChange }, { type: "checkbox", ref: (elem) => elem && (elem.indeterminate = isChecked === null), "aria-invalid": !isValid, disabled: isDisabled, checked: this.calculateChecked() }, getOUIAProps(_DropdownToggleCheckbox.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe))),
      isInProgress && React29.createElement("span", { className: css(dropdown_default.dropdownToggleProgress, className) }, spinner),
      text
    );
  }
};
DropdownToggleCheckbox.displayName = "DropdownToggleCheckbox";
DropdownToggleCheckbox.defaultProps = {
  className: "",
  isValid: true,
  isDisabled: false,
  onChange: () => void 0
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownToggleAction.js
var React30 = __toESM(require_react());
var DropdownToggleAction = class extends React30.Component {
  render() {
    const _a = this.props, { id, className, onClick, isDisabled, children } = _a, props = __rest(_a, ["id", "className", "onClick", "isDisabled", "children"]);
    return React30.createElement("button", Object.assign({ id, className: css(dropdown_default.dropdownToggleButton, className), onClick }, isDisabled && { disabled: true, "aria-disabled": true }, props), children);
  }
};
DropdownToggleAction.displayName = "DropdownToggleAction";
DropdownToggleAction.defaultProps = {
  className: "",
  isDisabled: false,
  onClick: () => {
  }
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/ApplicationLauncher/ApplicationLauncherSeparator.js
var React31 = __toESM(require_react());
var ApplicationLauncherSeparator = (_a) => {
  var {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    children
  } = _a, props = __rest(_a, ["children"]);
  return React31.createElement(DropdownSeparator, Object.assign({}, props));
};
ApplicationLauncherSeparator.displayName = "ApplicationLauncherSeparator";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/TextInput/TextInput.js
var React32 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/FormControl/form-control.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/FormControl/form-control.css";
var form_control_default = {
  "formControl": "pf-c-form-control",
  "modifiers": {
    "success": "pf-m-success",
    "plain": "pf-m-plain",
    "expanded": "pf-m-expanded",
    "icon": "pf-m-icon",
    "warning": "pf-m-warning",
    "search": "pf-m-search",
    "calendar": "pf-m-calendar",
    "clock": "pf-m-clock",
    "iconSprite": "pf-m-icon-sprite",
    "placeholder": "pf-m-placeholder",
    "resizeVertical": "pf-m-resize-vertical",
    "resizeHorizontal": "pf-m-resize-horizontal"
  },
  "themeDark": "pf-theme-dark"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/TextInput/TextInput.js
var TextInputTypes;
(function(TextInputTypes2) {
  TextInputTypes2["text"] = "text";
  TextInputTypes2["date"] = "date";
  TextInputTypes2["datetimeLocal"] = "datetime-local";
  TextInputTypes2["email"] = "email";
  TextInputTypes2["month"] = "month";
  TextInputTypes2["number"] = "number";
  TextInputTypes2["password"] = "password";
  TextInputTypes2["search"] = "search";
  TextInputTypes2["tel"] = "tel";
  TextInputTypes2["time"] = "time";
  TextInputTypes2["url"] = "url";
})(TextInputTypes || (TextInputTypes = {}));
var TextInputReadOnlyVariant;
(function(TextInputReadOnlyVariant2) {
  TextInputReadOnlyVariant2["default"] = "default";
  TextInputReadOnlyVariant2["plain"] = "plain";
})(TextInputReadOnlyVariant || (TextInputReadOnlyVariant = {}));
var TextInputBase = class _TextInputBase extends React32.Component {
  constructor(props) {
    super(props);
    this.inputRef = React32.createRef();
    this.observer = () => {
    };
    this.handleChange = (event) => {
      if (this.props.onChange) {
        this.props.onChange(event.currentTarget.value, event);
      }
    };
    this.handleResize = () => {
      const inputRef = this.props.innerRef || this.inputRef;
      if (inputRef && inputRef.current) {
        trimLeft(inputRef.current, String(this.props.value));
      }
    };
    this.restoreText = () => {
      const inputRef = this.props.innerRef || this.inputRef;
      inputRef.current.value = String(this.props.value);
      inputRef.current.scrollLeft = inputRef.current.scrollWidth;
    };
    this.onFocus = (event) => {
      const { isLeftTruncated, onFocus } = this.props;
      if (isLeftTruncated) {
        this.restoreText();
      }
      onFocus && onFocus(event);
    };
    this.onBlur = (event) => {
      const { isLeftTruncated, onBlur } = this.props;
      if (isLeftTruncated) {
        this.handleResize();
      }
      onBlur && onBlur(event);
    };
    this.sanitizeInputValue = (value) => typeof value === "string" ? value.replace(/\n/g, " ") : value;
    if (!props.id && !props["aria-label"] && !props["aria-labelledby"]) {
      console.error("Text input:", "Text input requires either an id or aria-label to be specified");
    }
    this.state = {
      ouiaStateId: getDefaultOUIAId(_TextInputBase.displayName)
    };
  }
  componentDidMount() {
    if (this.props.isLeftTruncated) {
      const inputRef = this.props.innerRef || this.inputRef;
      this.observer = getResizeObserver(inputRef.current, this.handleResize);
      this.handleResize();
    }
  }
  componentWillUnmount() {
    if (this.props.isLeftTruncated) {
      this.observer();
    }
  }
  render() {
    const _a = this.props, {
      innerRef,
      className,
      type,
      value,
      validated,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      onChange,
      onFocus,
      onBlur,
      isLeftTruncated,
      isReadOnly,
      readOnly,
      readOnlyVariant,
      isRequired,
      isDisabled,
      isIconSprite,
      iconVariant,
      customIconUrl,
      customIconDimensions,
      ouiaId,
      ouiaSafe
    } = _a, props = __rest(_a, ["innerRef", "className", "type", "value", "validated", "onChange", "onFocus", "onBlur", "isLeftTruncated", "isReadOnly", "readOnly", "readOnlyVariant", "isRequired", "isDisabled", "isIconSprite", "iconVariant", "customIconUrl", "customIconDimensions", "ouiaId", "ouiaSafe"]);
    const customIconStyle = {};
    if (customIconUrl) {
      customIconStyle.backgroundImage = `url('${customIconUrl}')`;
    }
    if (customIconDimensions) {
      customIconStyle.backgroundSize = customIconDimensions;
    }
    return React32.createElement("input", Object.assign({}, props, { onFocus: this.onFocus, onBlur: this.onBlur, className: css(form_control_default.formControl, isIconSprite && form_control_default.modifiers.iconSprite, readOnlyVariant === "plain" && form_control_default.modifiers.plain, validated === ValidatedOptions.success && form_control_default.modifiers.success, validated === ValidatedOptions.warning && form_control_default.modifiers.warning, (iconVariant && iconVariant !== "search" || customIconUrl) && form_control_default.modifiers.icon, iconVariant && form_control_default.modifiers[iconVariant], className), onChange: this.handleChange, type, value: this.sanitizeInputValue(value), "aria-invalid": props["aria-invalid"] ? props["aria-invalid"] : validated === ValidatedOptions.error, required: isRequired, disabled: isDisabled, readOnly: !!readOnlyVariant || isReadOnly || readOnly, ref: innerRef || this.inputRef }, (customIconUrl || customIconDimensions) && { style: customIconStyle }, getOUIAProps(TextInput.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe)));
  }
};
TextInputBase.displayName = "TextInputBase";
TextInputBase.defaultProps = {
  "aria-label": null,
  className: "",
  isRequired: false,
  validated: "default",
  isDisabled: false,
  isReadOnly: false,
  isIconSprite: false,
  type: TextInputTypes.text,
  isLeftTruncated: false,
  onChange: () => void 0,
  ouiaSafe: true
};
var TextInput = React32.forwardRef((props, ref) => React32.createElement(TextInputBase, Object.assign({}, props, { innerRef: ref })));
TextInput.displayName = "TextInput";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Select/selectConstants.js
var React33 = __toESM(require_react());
var SelectContext = React33.createContext(null);
var SelectProvider = SelectContext.Provider;
var SelectConsumer = SelectContext.Consumer;
var SelectVariant;
(function(SelectVariant2) {
  SelectVariant2["single"] = "single";
  SelectVariant2["checkbox"] = "checkbox";
  SelectVariant2["typeahead"] = "typeahead";
  SelectVariant2["typeaheadMulti"] = "typeaheadmulti";
})(SelectVariant || (SelectVariant = {}));
var SelectPosition;
(function(SelectPosition2) {
  SelectPosition2["right"] = "right";
  SelectPosition2["left"] = "left";
})(SelectPosition || (SelectPosition = {}));
var SelectDirection;
(function(SelectDirection2) {
  SelectDirection2["up"] = "up";
  SelectDirection2["down"] = "down";
})(SelectDirection || (SelectDirection = {}));
var SelectFooterTabbableItems = "input, button, select, textarea, a[href]";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Select/SelectOption.js
var React34 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Select/select.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Select/select.css";
var select_default = {
  "check": "pf-c-check",
  "checkLabel": "pf-c-check__label",
  "chipGroup": "pf-c-chip-group",
  "divider": "pf-c-divider",
  "formControl": "pf-c-form-control",
  "modifiers": {
    "invalid": "pf-m-invalid",
    "success": "pf-m-success",
    "warning": "pf-m-warning",
    "disabled": "pf-m-disabled",
    "active": "pf-m-active",
    "expanded": "pf-m-expanded",
    "plain": "pf-m-plain",
    "typeahead": "pf-m-typeahead",
    "placeholder": "pf-m-placeholder",
    "top": "pf-m-top",
    "alignRight": "pf-m-align-right",
    "static": "pf-m-static",
    "favorite": "pf-m-favorite",
    "favoriteAction": "pf-m-favorite-action",
    "focus": "pf-m-focus",
    "link": "pf-m-link",
    "action": "pf-m-action",
    "selected": "pf-m-selected",
    "description": "pf-m-description",
    "load": "pf-m-load",
    "loading": "pf-m-loading"
  },
  "select": "pf-c-select",
  "selectListItem": "pf-c-select__list-item",
  "selectMenu": "pf-c-select__menu",
  "selectMenuFieldset": "pf-c-select__menu-fieldset",
  "selectMenuFooter": "pf-c-select__menu-footer",
  "selectMenuGroup": "pf-c-select__menu-group",
  "selectMenuGroupTitle": "pf-c-select__menu-group-title",
  "selectMenuItem": "pf-c-select__menu-item",
  "selectMenuItemActionIcon": "pf-c-select__menu-item-action-icon",
  "selectMenuItemCount": "pf-c-select__menu-item-count",
  "selectMenuItemDescription": "pf-c-select__menu-item-description",
  "selectMenuItemIcon": "pf-c-select__menu-item-icon",
  "selectMenuItemMain": "pf-c-select__menu-item-main",
  "selectMenuItemMatch": "pf-c-select__menu-item--match",
  "selectMenuItemRow": "pf-c-select__menu-item-row",
  "selectMenuItemText": "pf-c-select__menu-item-text",
  "selectMenuSearch": "pf-c-select__menu-search",
  "selectMenuWrapper": "pf-c-select__menu-wrapper",
  "selectToggle": "pf-c-select__toggle",
  "selectToggleArrow": "pf-c-select__toggle-arrow",
  "selectToggleBadge": "pf-c-select__toggle-badge",
  "selectToggleButton": "pf-c-select__toggle-button",
  "selectToggleClear": "pf-c-select__toggle-clear",
  "selectToggleIcon": "pf-c-select__toggle-icon",
  "selectToggleStatusIcon": "pf-c-select__toggle-status-icon",
  "selectToggleText": "pf-c-select__toggle-text",
  "selectToggleTypeahead": "pf-c-select__toggle-typeahead",
  "selectToggleWrapper": "pf-c-select__toggle-wrapper",
  "themeDark": "pf-theme-dark"
};

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Check/check.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Check/check.css";
var check_default = {
  "check": "pf-c-check",
  "checkBody": "pf-c-check__body",
  "checkDescription": "pf-c-check__description",
  "checkInput": "pf-c-check__input",
  "checkLabel": "pf-c-check__label",
  "checkLabelRequired": "pf-c-check__label-required",
  "modifiers": {
    "standalone": "pf-m-standalone",
    "disabled": "pf-m-disabled"
  }
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Select/SelectOption.js
var SelectOption = class extends React34.Component {
  constructor() {
    super(...arguments);
    this.ref = React34.createRef();
    this.liRef = React34.createRef();
    this.favoriteRef = React34.createRef();
    this.onKeyDown = (event, innerIndex, onEnter, isCheckbox) => {
      const { index, keyHandler: keyHandler2, isLastOptionBeforeFooter } = this.props;
      let isLastItemBeforeFooter = false;
      if (isLastOptionBeforeFooter !== void 0) {
        isLastItemBeforeFooter = isLastOptionBeforeFooter(index);
      }
      if (event.key === KeyTypes.Tab) {
        if (isCheckbox && !isLastItemBeforeFooter) {
          if (event.shiftKey) {
            keyHandler2(index, innerIndex, "up");
          } else {
            keyHandler2(index, innerIndex, "down");
          }
          event.stopPropagation();
        } else {
          if (event.shiftKey) {
            keyHandler2(index, innerIndex, "up");
          } else {
            keyHandler2(index, innerIndex, "tab");
          }
        }
      }
      event.preventDefault();
      if (event.key === KeyTypes.ArrowUp) {
        keyHandler2(index, innerIndex, "up");
      } else if (event.key === KeyTypes.ArrowDown) {
        keyHandler2(index, innerIndex, "down");
      } else if (event.key === KeyTypes.ArrowLeft) {
        keyHandler2(index, innerIndex, "left");
      } else if (event.key === KeyTypes.ArrowRight) {
        keyHandler2(index, innerIndex, "right");
      } else if (event.key === KeyTypes.Enter) {
        if (onEnter !== void 0) {
          onEnter();
        } else {
          this.ref.current.click();
        }
      }
    };
  }
  componentDidMount() {
    this.props.sendRef(this.props.isDisabled ? null : this.ref.current, this.props.isDisabled ? null : this.favoriteRef.current, this.props.isDisabled ? null : this.liRef.current, this.props.index);
  }
  componentDidUpdate() {
    this.props.sendRef(this.props.isDisabled ? null : this.ref.current, this.props.isDisabled ? null : this.favoriteRef.current, this.props.isDisabled ? null : this.liRef.current, this.props.index);
  }
  render() {
    const _a = this.props, {
      children,
      className,
      id,
      description,
      itemCount,
      value,
      onClick,
      isDisabled,
      isPlaceholder,
      isNoResultsOption,
      isSelected,
      isChecked,
      isFocused,
      sendRef,
      keyHandler: keyHandler2,
      index,
      component,
      inputId,
      isFavorite,
      ariaIsFavoriteLabel = "starred",
      ariaIsNotFavoriteLabel = "not starred",
      isLoad,
      isLoading,
      setViewMoreNextIndex,
      // eslint-disable-next-line no-console
      isLastOptionBeforeFooter,
      isGrouped = false
    } = _a, props = __rest(_a, ["children", "className", "id", "description", "itemCount", "value", "onClick", "isDisabled", "isPlaceholder", "isNoResultsOption", "isSelected", "isChecked", "isFocused", "sendRef", "keyHandler", "index", "component", "inputId", "isFavorite", "ariaIsFavoriteLabel", "ariaIsNotFavoriteLabel", "isLoad", "isLoading", "setViewMoreNextIndex", "isLastOptionBeforeFooter", "isGrouped"]);
    const Component19 = component;
    if (!id && isFavorite !== null) {
      console.error("Please provide an id to use the favorites feature.");
    }
    const generatedId = id || getUniqueId("select-option");
    const favoriteButton = (onFavorite) => React34.createElement(
      "button",
      { className: css(select_default.selectMenuItem, select_default.modifiers.action, select_default.modifiers.favoriteAction), "aria-label": isFavorite ? ariaIsFavoriteLabel : ariaIsNotFavoriteLabel, onClick: () => {
        onFavorite(generatedId.replace("favorite-", ""), isFavorite);
      }, onKeyDown: (event) => {
        this.onKeyDown(event, 1, () => onFavorite(generatedId.replace("favorite-", ""), isFavorite));
      }, ref: this.favoriteRef },
      React34.createElement(
        "span",
        { className: css(select_default.selectMenuItemActionIcon) },
        React34.createElement(star_icon_default, null)
      )
    );
    const itemDisplay = itemCount ? React34.createElement(
      "span",
      { className: css(select_default.selectMenuItemRow) },
      React34.createElement("span", { className: css(select_default.selectMenuItemText) }, children || value && value.toString && value.toString()),
      React34.createElement("span", { className: css(select_default.selectMenuItemCount) }, itemCount)
    ) : children || value.toString();
    const onViewMoreClick = (event) => {
      setViewMoreNextIndex();
      onClick(event);
    };
    const renderOption = (onSelect, onClose, variant, inputIdPrefix, onFavorite, shouldResetOnSelect) => {
      if (variant !== SelectVariant.checkbox && isLoading && isGrouped) {
        return React34.createElement("div", { role: "presentation", className: css(select_default.selectListItem, isLoading && select_default.modifiers.loading, className) }, children);
      } else if (variant !== SelectVariant.checkbox && isLoad && isGrouped) {
        return React34.createElement(
          "div",
          null,
          React34.createElement("button", Object.assign({}, props, { role: "presentation", className: css(select_default.selectMenuItem, select_default.modifiers.load, className), onClick: (event) => {
            onViewMoreClick(event);
            event.stopPropagation();
          }, ref: this.ref, type: "button" }), children || value.toString())
        );
      } else if (variant !== SelectVariant.checkbox) {
        return React34.createElement(
          "li",
          { id: generatedId, role: "presentation", className: css(isLoading && select_default.selectListItem, !isLoading && select_default.selectMenuWrapper, isFavorite && select_default.modifiers.favorite, isFocused && select_default.modifiers.focus, isLoading && select_default.modifiers.loading), ref: this.liRef },
          isLoading && children,
          isLoad && !isGrouped && React34.createElement("button", Object.assign({}, props, { className: css(select_default.selectMenuItem, select_default.modifiers.load, className), onClick: (event) => {
            onViewMoreClick(event);
            event.stopPropagation();
          }, ref: this.ref, onKeyDown: (event) => {
            this.onKeyDown(event, 0);
          }, type: "button" }), itemDisplay),
          !isLoading && !isLoad && React34.createElement(
            React34.Fragment,
            null,
            React34.createElement(
              Component19,
              Object.assign({}, props, { className: css(select_default.selectMenuItem, isLoad && select_default.modifiers.load, isSelected && select_default.modifiers.selected, isDisabled && select_default.modifiers.disabled, description && select_default.modifiers.description, isFavorite !== null && select_default.modifiers.link, className), onClick: (event) => {
                if (!isDisabled) {
                  onClick(event);
                  onSelect(event, value, isPlaceholder);
                  shouldResetOnSelect && onClose();
                }
              }, role: "option", "aria-selected": isSelected || null, ref: this.ref, onKeyDown: (event) => {
                this.onKeyDown(event, 0);
              }, type: "button" }),
              description && React34.createElement(
                React34.Fragment,
                null,
                React34.createElement(
                  "span",
                  { className: css(select_default.selectMenuItemMain) },
                  itemDisplay,
                  isSelected && React34.createElement(
                    "span",
                    { className: css(select_default.selectMenuItemIcon) },
                    React34.createElement(check_icon_default, { "aria-hidden": true })
                  )
                ),
                React34.createElement("span", { className: css(select_default.selectMenuItemDescription) }, description)
              ),
              !description && React34.createElement(
                React34.Fragment,
                null,
                itemDisplay,
                isSelected && React34.createElement(
                  "span",
                  { className: css(select_default.selectMenuItemIcon) },
                  React34.createElement(check_icon_default, { "aria-hidden": true })
                )
              )
            ),
            isFavorite !== null && id && favoriteButton(onFavorite)
          )
        );
      } else if (variant === SelectVariant.checkbox && isLoad) {
        return React34.createElement("button", { className: css(select_default.selectMenuItem, select_default.modifiers.load, isFocused && select_default.modifiers.focus, className), onKeyDown: (event) => {
          this.onKeyDown(event, 0, void 0, true);
        }, onClick: (event) => {
          onViewMoreClick(event);
          event.stopPropagation();
        }, ref: this.ref }, children || value && value.toString && value.toString());
      } else if (variant === SelectVariant.checkbox && isLoading) {
        return React34.createElement("div", { className: css(select_default.selectListItem, isLoading && select_default.modifiers.loading, className) }, children);
      } else if (variant === SelectVariant.checkbox && !isNoResultsOption && !isLoading && !isLoad) {
        return React34.createElement(
          "label",
          Object.assign({}, props, { className: css(check_default.check, select_default.selectMenuItem, isDisabled && select_default.modifiers.disabled, description && select_default.modifiers.description, className), onKeyDown: (event) => {
            this.onKeyDown(event, 0, void 0, true);
          } }),
          React34.createElement("input", { id: inputId || `${inputIdPrefix}-${value.toString()}`, className: css(check_default.checkInput), type: "checkbox", onChange: (event) => {
            if (!isDisabled) {
              onClick(event);
              onSelect(event, value);
            }
          }, ref: this.ref, checked: isChecked || false, disabled: isDisabled }),
          React34.createElement("span", { className: css(check_default.checkLabel, isDisabled && select_default.modifiers.disabled) }, itemDisplay),
          description && React34.createElement("div", { className: css(check_default.checkDescription) }, description)
        );
      } else if (variant === SelectVariant.checkbox && isNoResultsOption && !isLoading && !isLoad) {
        return React34.createElement(
          "div",
          null,
          React34.createElement(Component19, Object.assign({}, props, { className: css(select_default.selectMenuItem, isSelected && select_default.modifiers.selected, isDisabled && select_default.modifiers.disabled, className), role: "option", "aria-selected": isSelected || null, ref: this.ref, onKeyDown: (event) => {
            this.onKeyDown(event, 0, void 0, true);
          }, type: "button" }), itemDisplay)
        );
      }
    };
    return React34.createElement(SelectConsumer, null, ({ onSelect, onClose, variant, inputIdPrefix, onFavorite, shouldResetOnSelect }) => React34.createElement(React34.Fragment, null, renderOption(onSelect, onClose, variant, inputIdPrefix, onFavorite, shouldResetOnSelect)));
  }
};
SelectOption.displayName = "SelectOption";
SelectOption.defaultProps = {
  className: "",
  value: "",
  index: 0,
  isDisabled: false,
  isPlaceholder: false,
  isSelected: false,
  isChecked: false,
  isNoResultsOption: false,
  component: "button",
  onClick: () => {
  },
  sendRef: () => {
  },
  keyHandler: () => {
  },
  inputId: "",
  isFavorite: null,
  isLoad: false,
  isLoading: false,
  setViewMoreNextIndex: () => {
  },
  isLastOptionBeforeFooter: () => false
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Select/SelectGroup.js
var React35 = __toESM(require_react());
var SelectGroup = (_a) => {
  var { children = [], className = "", label = "", titleId = "" } = _a, props = __rest(_a, ["children", "className", "label", "titleId"]);
  return React35.createElement(SelectConsumer, null, ({ variant }) => React35.createElement(
    "div",
    Object.assign({}, props, { className: css(select_default.selectMenuGroup, className) }),
    React35.createElement("div", { className: css(select_default.selectMenuGroupTitle), id: titleId, "aria-hidden": true }, label),
    variant === SelectVariant.checkbox ? children : React35.createElement("ul", { role: "listbox" }, children)
  ));
};
SelectGroup.displayName = "SelectGroup";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Chip/Chip.js
var React36 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Chip/chip.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Chip/chip.css";
var chip_default = {
  "badge": "pf-c-badge",
  "button": "pf-c-button",
  "chip": "pf-c-chip",
  "chipIcon": "pf-c-chip__icon",
  "chipText": "pf-c-chip__text",
  "modifiers": {
    "overflow": "pf-m-overflow",
    "draggable": "pf-m-draggable"
  },
  "themeDark": "pf-theme-dark"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Chip/Chip.js
var Chip = class _Chip extends React36.Component {
  constructor(props) {
    super(props);
    this.span = React36.createRef();
    this.setChipStyle = () => ({
      "--pf-c-chip__text--MaxWidth": this.props.textMaxWidth
    });
    this.renderOverflowChip = () => {
      const _a = this.props, {
        children,
        className,
        onClick,
        ouiaId,
        textMaxWidth,
        style,
        component,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        tooltipPosition,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        isOverflowChip,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        closeBtnAriaLabel,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        isReadOnly
      } = _a, props2 = __rest(_a, ["children", "className", "onClick", "ouiaId", "textMaxWidth", "style", "component", "tooltipPosition", "isOverflowChip", "closeBtnAriaLabel", "isReadOnly"]);
      const Component19 = component;
      return React36.createElement(
        Component19,
        Object.assign({ onClick }, textMaxWidth && Object.assign({ style: this.setChipStyle() }, style), { className: css(chip_default.chip, chip_default.modifiers.overflow, className) }, component === "button" ? { type: "button" } : {}, getOUIAProps("OverflowChip", ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId), props2),
        React36.createElement("span", { className: css(chip_default.chipText) }, children)
      );
    };
    this.renderChip = (randomId) => {
      const { children, tooltipPosition } = this.props;
      if (this.state.isTooltipVisible) {
        return React36.createElement(Tooltip, { position: tooltipPosition, content: children }, this.renderInnerChip(randomId));
      }
      return this.renderInnerChip(randomId);
    };
    this.state = {
      isTooltipVisible: false,
      ouiaStateId: getDefaultOUIAId(_Chip.displayName)
    };
  }
  componentDidMount() {
    this.setState({
      isTooltipVisible: Boolean(this.span.current && this.span.current.offsetWidth < this.span.current.scrollWidth)
    });
  }
  renderInnerChip(id) {
    const _a = this.props, {
      children,
      className,
      onClick,
      closeBtnAriaLabel,
      isReadOnly,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      isOverflowChip,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      tooltipPosition,
      component,
      ouiaId
    } = _a, props = __rest(_a, ["children", "className", "onClick", "closeBtnAriaLabel", "isReadOnly", "isOverflowChip", "tooltipPosition", "component", "ouiaId"]);
    const Component19 = component;
    return React36.createElement(
      Component19,
      Object.assign({}, this.props.textMaxWidth && {
        style: this.setChipStyle()
      }, { className: css(chip_default.chip, className) }, this.state.isTooltipVisible && { tabIndex: 0 }, getOUIAProps(_Chip.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId), props),
      React36.createElement("span", { ref: this.span, className: css(chip_default.chipText), id }, children),
      !isReadOnly && React36.createElement(
        Button,
        { onClick, variant: "plain", "aria-label": closeBtnAriaLabel, id: `remove_${id}`, "aria-labelledby": `remove_${id} ${id}`, ouiaId: ouiaId || closeBtnAriaLabel },
        React36.createElement(times_icon_default, { "aria-hidden": "true" })
      )
    );
  }
  render() {
    const { isOverflowChip } = this.props;
    return React36.createElement(GenerateId, null, (randomId) => isOverflowChip ? this.renderOverflowChip() : this.renderChip(this.props.id || randomId));
  }
};
Chip.displayName = "Chip";
Chip.defaultProps = {
  closeBtnAriaLabel: "close",
  className: "",
  isOverflowChip: false,
  isReadOnly: false,
  tooltipPosition: "top",
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onClick: (_e) => void 0,
  component: "div"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/ChipGroup/ChipGroup.js
var React37 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/ChipGroup/chip-group.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/ChipGroup/chip-group.css";
var chip_group_default = {
  "chipGroup": "pf-c-chip-group",
  "chipGroupClose": "pf-c-chip-group__close",
  "chipGroupLabel": "pf-c-chip-group__label",
  "chipGroupList": "pf-c-chip-group__list",
  "chipGroupListItem": "pf-c-chip-group__list-item",
  "chipGroupMain": "pf-c-chip-group__main",
  "modifiers": {
    "category": "pf-m-category"
  }
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/ChipGroup/ChipGroup.js
var ChipGroup = class _ChipGroup extends React37.Component {
  constructor(props) {
    super(props);
    this.headingRef = React37.createRef();
    this.toggleCollapse = () => {
      this.setState((prevState) => ({
        isOpen: !prevState.isOpen,
        isTooltipVisible: Boolean(this.headingRef.current && this.headingRef.current.offsetWidth < this.headingRef.current.scrollWidth)
      }));
    };
    this.state = {
      isOpen: this.props.defaultIsOpen,
      isTooltipVisible: false
    };
  }
  componentDidMount() {
    this.setState({
      isTooltipVisible: Boolean(this.headingRef.current && this.headingRef.current.offsetWidth < this.headingRef.current.scrollWidth)
    });
  }
  renderLabel(id) {
    const { categoryName, tooltipPosition } = this.props;
    const { isTooltipVisible } = this.state;
    return isTooltipVisible ? React37.createElement(
      Tooltip,
      { position: tooltipPosition, content: categoryName },
      React37.createElement(
        "span",
        { tabIndex: 0, ref: this.headingRef, className: css(chip_group_default.chipGroupLabel) },
        React37.createElement("span", { id }, categoryName)
      )
    ) : React37.createElement("span", { ref: this.headingRef, className: css(chip_group_default.chipGroupLabel), id }, categoryName);
  }
  render() {
    const _a = this.props, {
      categoryName,
      children,
      className,
      isClosable,
      closeBtnAriaLabel,
      "aria-label": ariaLabel,
      onClick,
      onOverflowChipClick,
      numChips,
      expandedText,
      collapsedText,
      ouiaId,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      defaultIsOpen,
      tooltipPosition
    } = _a, rest = __rest(_a, ["categoryName", "children", "className", "isClosable", "closeBtnAriaLabel", "aria-label", "onClick", "onOverflowChipClick", "numChips", "expandedText", "collapsedText", "ouiaId", "defaultIsOpen", "tooltipPosition"]);
    const { isOpen } = this.state;
    const numChildren = React37.Children.count(children);
    const collapsedTextResult = fillTemplate(collapsedText, {
      remaining: React37.Children.count(children) - numChips
    });
    const renderChipGroup = (id) => {
      const chipArray = !isOpen ? React37.Children.toArray(children).slice(0, numChips) : React37.Children.toArray(children);
      return React37.createElement(
        "div",
        Object.assign({ className: css(chip_group_default.chipGroup, className, categoryName && chip_group_default.modifiers.category), role: "group" }, categoryName && { "aria-labelledby": id }, !categoryName && { "aria-label": ariaLabel }, getOUIAProps(_ChipGroup.displayName, ouiaId)),
        React37.createElement(
          "div",
          { className: css(chip_group_default.chipGroupMain) },
          categoryName && this.renderLabel(id),
          React37.createElement(
            "ul",
            Object.assign({ className: css(chip_group_default.chipGroupList) }, categoryName && { "aria-labelledby": id }, !categoryName && { "aria-label": ariaLabel }, { role: "list" }, rest),
            chipArray.map((child, i) => React37.createElement("li", { className: css(chip_group_default.chipGroupListItem), key: i }, child)),
            numChildren > numChips && React37.createElement(
              "li",
              { className: css(chip_group_default.chipGroupListItem) },
              React37.createElement(Chip, { isOverflowChip: true, onClick: (event) => {
                this.toggleCollapse();
                onOverflowChipClick(event);
              }, component: "button" }, isOpen ? expandedText : collapsedTextResult)
            )
          )
        ),
        isClosable && React37.createElement(
          "div",
          { className: css(chip_group_default.chipGroupClose) },
          React37.createElement(
            Button,
            { variant: "plain", "aria-label": closeBtnAriaLabel, onClick, id: `remove_group_${id}`, "aria-labelledby": `remove_group_${id} ${id}`, ouiaId: ouiaId || closeBtnAriaLabel },
            React37.createElement(times_circle_icon_default, { "aria-hidden": "true" })
          )
        )
      );
    };
    return numChildren === 0 ? null : React37.createElement(GenerateId, null, (randomId) => renderChipGroup(this.props.id || randomId));
  }
};
ChipGroup.displayName = "ChipGroup";
ChipGroup.defaultProps = {
  expandedText: "Show Less",
  collapsedText: "${remaining} more",
  categoryName: "",
  defaultIsOpen: false,
  numChips: 3,
  isClosable: false,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onClick: (_e) => void 0,
  onOverflowChipClick: (_e) => void 0,
  closeBtnAriaLabel: "Close chip group",
  tooltipPosition: "top",
  "aria-label": "Chip group category"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Select/Select.js
var React41 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Select/SelectMenu.js
var React38 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Form/form.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Form/form.css";
var form_default = {
  "form": "pf-c-form",
  "formActions": "pf-c-form__actions",
  "formFieldGroup": "pf-c-form__field-group",
  "formFieldGroupBody": "pf-c-form__field-group-body",
  "formFieldGroupHeader": "pf-c-form__field-group-header",
  "formFieldGroupHeaderActions": "pf-c-form__field-group-header-actions",
  "formFieldGroupHeaderDescription": "pf-c-form__field-group-header-description",
  "formFieldGroupHeaderMain": "pf-c-form__field-group-header-main",
  "formFieldGroupHeaderTitle": "pf-c-form__field-group-header-title",
  "formFieldGroupHeaderTitleText": "pf-c-form__field-group-header-title-text",
  "formFieldGroupToggle": "pf-c-form__field-group-toggle",
  "formFieldGroupToggleButton": "pf-c-form__field-group-toggle-button",
  "formFieldGroupToggleIcon": "pf-c-form__field-group-toggle-icon",
  "formFieldset": "pf-c-form__fieldset",
  "formGroup": "pf-c-form__group",
  "formGroupControl": "pf-c-form__group-control",
  "formGroupLabel": "pf-c-form__group-label",
  "formGroupLabelHelp": "pf-c-form__group-label-help",
  "formGroupLabelInfo": "pf-c-form__group-label-info",
  "formGroupLabelMain": "pf-c-form__group-label-main",
  "formHelperText": "pf-c-form__helper-text",
  "formHelperTextIcon": "pf-c-form__helper-text-icon",
  "formLabel": "pf-c-form__label",
  "formLabelRequired": "pf-c-form__label-required",
  "formLabelText": "pf-c-form__label-text",
  "formSection": "pf-c-form__section",
  "formSectionTitle": "pf-c-form__section-title",
  "modifiers": {
    "horizontal": "pf-m-horizontal",
    "alignRight": "pf-m-align-right",
    "noPaddingTop": "pf-m-no-padding-top",
    "horizontalOnXs": "pf-m-horizontal-on-xs",
    "horizontalOnSm": "pf-m-horizontal-on-sm",
    "horizontalOnMd": "pf-m-horizontal-on-md",
    "horizontalOnLg": "pf-m-horizontal-on-lg",
    "horizontalOnXl": "pf-m-horizontal-on-xl",
    "horizontalOn_2xl": "pf-m-horizontal-on-2xl",
    "limitWidth": "pf-m-limit-width",
    "action": "pf-m-action",
    "info": "pf-m-info",
    "disabled": "pf-m-disabled",
    "inline": "pf-m-inline",
    "stack": "pf-m-stack",
    "error": "pf-m-error",
    "success": "pf-m-success",
    "warning": "pf-m-warning",
    "inactive": "pf-m-inactive",
    "hidden": "pf-m-hidden",
    "expanded": "pf-m-expanded"
  },
  "themeDark": "pf-theme-dark"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Select/SelectMenu.js
var SelectMenuWithRef = class extends React38.Component {
  extendChildren(randomId) {
    const { children, hasInlineFilter, isGrouped } = this.props;
    const childrenArray = children;
    let index = hasInlineFilter ? 1 : 0;
    if (isGrouped) {
      return React38.Children.map(childrenArray, (group) => {
        if (group.type === SelectGroup) {
          return React38.cloneElement(group, {
            titleId: group.props.label && group.props.label.replace(/\W/g, "-"),
            children: React38.Children.map(group.props.children, (option) => this.cloneOption(option, index++, randomId))
          });
        } else {
          return this.cloneOption(group, index++, randomId);
        }
      });
    }
    return React38.Children.map(childrenArray, (child) => this.cloneOption(child, index++, randomId));
  }
  cloneOption(child, index, randomId) {
    const { selected, sendRef, keyHandler: keyHandler2 } = this.props;
    const isSelected = this.checkForValue(child.props.value, selected);
    if (child.type === Divider) {
      return child;
    }
    return React38.cloneElement(child, {
      inputId: `${randomId}-${index}`,
      isSelected,
      sendRef,
      keyHandler: keyHandler2,
      index
    });
  }
  checkForValue(valueToCheck, options) {
    if (!options || !valueToCheck) {
      return false;
    }
    const isSelectOptionObject = typeof valueToCheck !== "string" && valueToCheck.toString && valueToCheck.compareTo;
    if (Array.isArray(options)) {
      if (isSelectOptionObject) {
        return options.some((option) => option.compareTo(valueToCheck));
      } else {
        return options.includes(valueToCheck);
      }
    } else {
      if (isSelectOptionObject) {
        return options.compareTo(valueToCheck);
      } else {
        return options === valueToCheck;
      }
    }
  }
  extendCheckboxChildren(children) {
    const { isGrouped, checked, sendRef, keyHandler: keyHandler2, hasInlineFilter, isLastOptionBeforeFooter } = this.props;
    let index = hasInlineFilter ? 1 : 0;
    if (isGrouped) {
      return React38.Children.map(children, (group) => {
        if (group.type === Divider) {
          return group;
        } else if (group.type === SelectOption) {
          return React38.cloneElement(group, {
            isChecked: this.checkForValue(group.props.value, checked),
            sendRef,
            keyHandler: keyHandler2,
            index: index++,
            isLastOptionBeforeFooter
          });
        }
        return React38.cloneElement(group, {
          titleId: group.props.label && group.props.label.replace(/\W/g, "-"),
          children: group.props.children ? React38.createElement("fieldset", { "aria-labelledby": group.props.label && group.props.label.replace(/\W/g, "-"), className: css(select_default.selectMenuFieldset) }, React38.Children.map(group.props.children, (option) => option.type === Divider ? option : React38.cloneElement(option, {
            isChecked: this.checkForValue(option.props.value, checked),
            sendRef,
            keyHandler: keyHandler2,
            index: index++,
            isLastOptionBeforeFooter
          }))) : null
        });
      });
    }
    return React38.Children.map(children, (child) => child.type === Divider ? child : React38.cloneElement(child, {
      isChecked: this.checkForValue(child.props.value, checked),
      sendRef,
      keyHandler: keyHandler2,
      index: index++,
      isLastOptionBeforeFooter
    }));
  }
  renderSelectMenu({ variant, inputIdPrefix }) {
    const _a = this.props, { children, isCustomContent, className, isExpanded, openedOnEnter, selected, checked, isGrouped, position, sendRef, keyHandler: keyHandler2, maxHeight, noResultsFoundText, createText, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, hasInlineFilter, innerRef, footer, footerRef, isLastOptionBeforeFooter } = _a, props = __rest(_a, ["children", "isCustomContent", "className", "isExpanded", "openedOnEnter", "selected", "checked", "isGrouped", "position", "sendRef", "keyHandler", "maxHeight", "noResultsFoundText", "createText", "aria-label", "aria-labelledby", "hasInlineFilter", "innerRef", "footer", "footerRef", "isLastOptionBeforeFooter"]);
    let Component19 = "div";
    const variantProps = Object.assign({ ref: innerRef, className: css(!footer ? select_default.selectMenu : "pf-c-select__menu-list", position === SelectPosition.right && select_default.modifiers.alignRight, className) }, maxHeight && { style: { maxHeight, overflow: "auto" } });
    const extendedChildren = () => variant === SelectVariant.checkbox ? this.extendCheckboxChildren(children) : this.extendChildren(inputIdPrefix);
    if (isCustomContent) {
      variantProps.children = children;
    } else if (hasInlineFilter) {
      if (React38.Children.count(children) === 0) {
        variantProps.children = React38.createElement("fieldset", { className: css(select_default.selectMenuFieldset) });
      } else {
        variantProps.children = React38.createElement(
          "fieldset",
          { "aria-label": ariaLabel, "aria-labelledby": !ariaLabel && ariaLabelledBy || null, className: css(form_default.formFieldset) },
          children.shift(),
          extendedChildren()
        );
      }
    } else {
      variantProps.children = extendedChildren();
      if (!isGrouped) {
        Component19 = "ul";
        variantProps.role = "listbox";
        variantProps["aria-label"] = ariaLabel;
        variantProps["aria-labelledby"] = !ariaLabel && ariaLabelledBy || null;
      }
    }
    return React38.createElement(
      React38.Fragment,
      null,
      React38.createElement(Component19, Object.assign({}, variantProps, props)),
      footer && React38.createElement("div", { className: css(select_default.selectMenuFooter), ref: footerRef }, footer)
    );
  }
  render() {
    return React38.createElement(SelectConsumer, null, (context) => this.renderSelectMenu(context));
  }
};
SelectMenuWithRef.displayName = "SelectMenu";
SelectMenuWithRef.defaultProps = {
  className: "",
  isExpanded: false,
  isGrouped: false,
  openedOnEnter: false,
  selected: "",
  maxHeight: "",
  position: SelectPosition.left,
  sendRef: () => {
  },
  keyHandler: () => {
  },
  isCustomContent: false,
  hasInlineFilter: false,
  isLastOptionBeforeFooter: () => {
  }
};
var SelectMenu = React38.forwardRef((props, ref) => React38.createElement(SelectMenuWithRef, Object.assign({ innerRef: ref }, props), props.children));

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Select/SelectToggle.js
var React39 = __toESM(require_react());
var SelectToggleBase = class extends React39.Component {
  constructor(props) {
    super(props);
    this.onDocClick = (event) => {
      const { parentRef, menuRef, footerRef, isOpen, onToggle, onClose } = this.props;
      const clickedOnToggle = parentRef && parentRef.current && parentRef.current.contains(event.target);
      const clickedWithinMenu = menuRef && menuRef.current && menuRef.current.contains && menuRef.current.contains(event.target);
      const clickedWithinFooter = footerRef && footerRef.current && footerRef.current.contains && footerRef.current.contains(event.target);
      if (isOpen && !(clickedOnToggle || clickedWithinMenu || clickedWithinFooter)) {
        onToggle(false, event);
        onClose();
      }
    };
    this.handleGlobalKeys = (event) => {
      const { parentRef, menuRef, hasFooter, footerRef, isOpen, variant: variant2, onToggle, onClose, moveFocusToLastMenuItem } = this.props;
      const escFromToggle = parentRef && parentRef.current && parentRef.current.contains(event.target);
      const escFromWithinMenu = menuRef && menuRef.current && menuRef.current.contains && menuRef.current.contains(event.target);
      if (isOpen && event.key === KeyTypes.Tab && (variant2 === SelectVariant.typeahead || variant2 === SelectVariant.typeaheadMulti)) {
        this.props.handleTypeaheadKeys("tab", event.shiftKey);
        event.preventDefault();
        return;
      }
      if (isOpen && event.key === KeyTypes.Tab && hasFooter) {
        const tabbableItems = findTabbableElements(footerRef, SelectFooterTabbableItems);
        if (tabbableItems.length <= 0) {
          onToggle(false, event);
          onClose();
          this.toggle.current.focus();
          return;
        } else {
          const currentElementIndex = tabbableItems.findIndex((item) => item === document.activeElement);
          if (currentElementIndex === -1) {
            if (event.shiftKey) {
              if (variant2 !== "checkbox") {
                onToggle(false, event);
                onClose();
                this.toggle.current.focus();
              }
            } else {
              tabbableItems[0].focus();
              return;
            }
          }
          if (event.shiftKey) {
            if (currentElementIndex === 0) {
              moveFocusToLastMenuItem();
              event.preventDefault();
            }
            return;
          }
          if (currentElementIndex + 1 < tabbableItems.length) {
            tabbableItems[currentElementIndex + 1].focus();
          } else {
            onToggle(false, event);
            onClose();
            this.toggle.current.focus();
          }
          event.preventDefault();
          return;
        }
      }
      if (isOpen && (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) && (escFromToggle || escFromWithinMenu)) {
        onToggle(false, event);
        onClose();
        this.toggle.current.focus();
      }
    };
    this.onKeyDown = (event) => {
      const { isOpen, onToggle, variant: variant2, onClose, onEnter, handleTypeaheadKeys } = this.props;
      if (variant2 === SelectVariant.typeahead || variant2 === SelectVariant.typeaheadMulti) {
        if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {
          handleTypeaheadKeys(event.key === KeyTypes.ArrowDown && "down" || event.key === KeyTypes.ArrowUp && "up");
          event.preventDefault();
        } else if (event.key === KeyTypes.Enter) {
          if (isOpen) {
            handleTypeaheadKeys("enter");
          } else {
            onToggle(!isOpen, event);
          }
        }
      }
      if (variant2 === SelectVariant.typeahead || variant2 === SelectVariant.typeaheadMulti || event.key === KeyTypes.Tab && !isOpen || event.key !== KeyTypes.Enter && event.key !== KeyTypes.Space) {
        return;
      }
      event.preventDefault();
      if ((event.key === KeyTypes.Tab || event.key === KeyTypes.Enter || event.key === KeyTypes.Space) && isOpen) {
        onToggle(!isOpen, event);
        onClose();
        this.toggle.current.focus();
      } else if ((event.key === KeyTypes.Enter || event.key === KeyTypes.Space) && !isOpen) {
        onToggle(!isOpen, event);
        onEnter();
      }
    };
    const { variant } = props;
    const isTypeahead = variant === SelectVariant.typeahead || variant === SelectVariant.typeaheadMulti;
    if (this.props.innerRef) {
      this.toggle = this.props.innerRef;
    } else {
      this.toggle = isTypeahead ? React39.createRef() : React39.createRef();
    }
  }
  componentDidMount() {
    document.addEventListener("click", this.onDocClick, { capture: true });
    document.addEventListener("touchstart", this.onDocClick);
    document.addEventListener("keydown", this.handleGlobalKeys);
  }
  componentWillUnmount() {
    document.removeEventListener("click", this.onDocClick, { capture: true });
    document.removeEventListener("touchstart", this.onDocClick);
    document.removeEventListener("keydown", this.handleGlobalKeys);
  }
  render() {
    const _a = this.props, { className, children, isOpen, isActive, isPlain, isDisabled, hasPlaceholderStyle, variant, onToggle, onEnter, onClose, onBlur, onClickTypeaheadToggleButton, handleTypeaheadKeys, moveFocusToLastMenuItem, parentRef, menuRef, id, type, hasClearButton, "aria-labelledby": ariaLabelledBy, "aria-label": ariaLabel, hasFooter, footerRef, toggleIndicator, innerRef } = _a, props = __rest(_a, ["className", "children", "isOpen", "isActive", "isPlain", "isDisabled", "hasPlaceholderStyle", "variant", "onToggle", "onEnter", "onClose", "onBlur", "onClickTypeaheadToggleButton", "handleTypeaheadKeys", "moveFocusToLastMenuItem", "parentRef", "menuRef", "id", "type", "hasClearButton", "aria-labelledby", "aria-label", "hasFooter", "footerRef", "toggleIndicator", "innerRef"]);
    const isTypeahead = variant === SelectVariant.typeahead || variant === SelectVariant.typeaheadMulti || hasClearButton;
    const toggleProps = {
      id,
      "aria-labelledby": ariaLabelledBy,
      "aria-expanded": isOpen,
      "aria-haspopup": variant !== SelectVariant.checkbox && "listbox" || null
    };
    return React39.createElement(
      React39.Fragment,
      null,
      !isTypeahead && React39.createElement(
        "button",
        Object.assign({}, props, toggleProps, {
          ref: this.toggle,
          type,
          className: css(select_default.selectToggle, hasPlaceholderStyle && select_default.modifiers.placeholder, isDisabled && select_default.modifiers.disabled, isPlain && select_default.modifiers.plain, isActive && select_default.modifiers.active, className),
          "aria-label": ariaLabel,
          onBlur,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          onClick: (event) => {
            onToggle(!isOpen, event);
            if (isOpen) {
              onClose();
            }
          },
          onKeyDown: this.onKeyDown,
          disabled: isDisabled
        }),
        children,
        React39.createElement("span", { className: css(select_default.selectToggleArrow) }, toggleIndicator !== null && toggleIndicator !== void 0 ? toggleIndicator : React39.createElement(caret_down_icon_default, null))
      ),
      isTypeahead && React39.createElement(
        "div",
        Object.assign({}, props, {
          ref: this.toggle,
          className: css(select_default.selectToggle, hasPlaceholderStyle && select_default.modifiers.placeholder, isDisabled && select_default.modifiers.disabled, isPlain && select_default.modifiers.plain, isTypeahead && select_default.modifiers.typeahead, className),
          onBlur,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          onClick: (event) => {
            if (!isDisabled) {
              onToggle(!isOpen, event);
              if (isOpen) {
                onClose();
              }
            }
          },
          onKeyDown: this.onKeyDown
        }),
        children,
        React39.createElement("button", Object.assign({}, toggleProps, { type, className: css(button_default.button, select_default.selectToggleButton, select_default.modifiers.plain), "aria-label": ariaLabel, onClick: (event) => {
          onToggle(!isOpen, event);
          if (isOpen) {
            onClose();
          }
          onClickTypeaheadToggleButton();
        } }, (variant === SelectVariant.typeahead || variant === SelectVariant.typeaheadMulti) && {
          tabIndex: -1
        }, { disabled: isDisabled }), toggleIndicator !== null && toggleIndicator !== void 0 ? toggleIndicator : React39.createElement(caret_down_icon_default, { className: css(select_default.selectToggleArrow) }))
      )
    );
  }
};
SelectToggleBase.displayName = "SelectToggle";
SelectToggleBase.defaultProps = {
  className: "",
  isOpen: false,
  isActive: false,
  isPlain: false,
  isDisabled: false,
  hasPlaceholderStyle: false,
  hasClearButton: false,
  hasFooter: false,
  variant: "single",
  "aria-labelledby": "",
  "aria-label": "",
  type: "button",
  onToggle: () => {
  },
  onEnter: () => {
  },
  onClose: () => {
  },
  onClickTypeaheadToggleButton: () => {
  }
};
var SelectToggle = React39.forwardRef((props, ref) => React39.createElement(SelectToggleBase, Object.assign({ innerRef: ref }, props)));

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/helpers/favorites.js
var React40 = __toESM(require_react());
var createRenderableFavorites = (items, isGrouped, favorites, isEnterTriggersArrowDown) => {
  if (isGrouped) {
    const favoriteItems = [];
    items.forEach((group) => {
      if (favorites.length > 0) {
        return group.props.children && group.props.children.filter((item) => favorites.includes(item.props.id)).map((item) => {
          if (isEnterTriggersArrowDown) {
            return favoriteItems.push(React40.cloneElement(item, {
              isFavorite: true,
              enterTriggersArrowDown: isEnterTriggersArrowDown,
              id: `favorite-${item.props.id}`
            }));
          } else {
            return favoriteItems.push(React40.cloneElement(item, { isFavorite: true, id: `favorite-${item.props.id}` }));
          }
        });
      }
    });
    return favoriteItems;
  }
  return items.filter((item) => favorites.includes(item.props.id)).map((item) => React40.cloneElement(item, { isFavorite: true, enterTriggersArrowDown: isEnterTriggersArrowDown }));
};
var extendItemsWithFavorite = (items, isGrouped, favorites) => {
  if (isGrouped) {
    return items.map((group) => React40.cloneElement(group, {
      children: React40.Children.map(group.props.children, (item) => {
        if (item.type === ApplicationLauncherSeparator || item.type === Divider) {
          return item;
        }
        return React40.cloneElement(item, {
          isFavorite: favorites.some((favoriteId) => favoriteId === item.props.id || `favorite-${favoriteId}` === item.props.id)
        });
      })
    }));
  }
  return items.map((item) => React40.cloneElement(item, {
    isFavorite: favorites.some((favoriteId) => favoriteId === item.props.id)
  }));
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Select/Select.js
var currentId2 = 0;
var Select = class _Select extends React41.Component {
  constructor() {
    super(...arguments);
    this.parentRef = React41.createRef();
    this.menuComponentRef = React41.createRef();
    this.filterRef = React41.createRef();
    this.clearRef = React41.createRef();
    this.inputRef = React41.createRef();
    this.refCollection = [[]];
    this.optionContainerRefCollection = [];
    this.footerRef = React41.createRef();
    this.state = {
      focusFirstOption: false,
      typeaheadInputValue: null,
      typeaheadFilteredChildren: React41.Children.toArray(this.props.children),
      favoritesGroup: [],
      typeaheadCurrIndex: -1,
      typeaheadStoredIndex: -1,
      creatableValue: "",
      tabbedIntoFavoritesMenu: false,
      ouiaStateId: getDefaultOUIAId(_Select.displayName, this.props.variant),
      viewMoreNextIndex: -1
    };
    this.getTypeaheadActiveChild = (typeaheadCurrIndex) => this.refCollection[typeaheadCurrIndex] ? this.refCollection[typeaheadCurrIndex][0] : null;
    this.componentDidUpdate = (prevProps, prevState) => {
      if (this.props.hasInlineFilter) {
        this.refCollection[0][0] = this.filterRef.current;
      }
      if (!prevState.focusFirstOption && this.state.focusFirstOption && !this.props.customContent) {
        const firstRef = this.refCollection.find((ref) => (
          // If a select option is disabled then ref[0] will be undefined, so we want to return
          // the first ref that both a) is not null and b) is not disabled.
          ref !== null && ref[0]
        ));
        if (firstRef && firstRef[0]) {
          firstRef[0].focus();
        }
      } else if (
        // if viewMoreNextIndex is not -1, view more was clicked, set focus on first newly loaded item
        this.state.viewMoreNextIndex !== -1 && this.refCollection.length > this.state.viewMoreNextIndex && this.props.loadingVariant !== "spinner" && this.refCollection[this.state.viewMoreNextIndex][0] && this.props.variant !== "typeahead" && // do not hard focus newly added items for typeahead variants
        this.props.variant !== "typeaheadmulti"
      ) {
        this.refCollection[this.state.viewMoreNextIndex][0].focus();
        this.setState({ viewMoreNextIndex: -1 });
      }
      const checkUpdatedChildren = (prevChildren, currChildren) => Array.from(prevChildren).some((prevChild, index) => {
        const prevChildProps = prevChild.props;
        const currChild = currChildren[index];
        const { props: currChildProps } = currChild;
        if (prevChildProps && currChildProps) {
          return prevChildProps.value !== currChildProps.value || prevChildProps.label !== currChildProps.label || prevChildProps.isDisabled !== currChildProps.isDisabled || prevChildProps.isPlaceholder !== currChildProps.isPlaceholder;
        } else {
          return prevChild !== currChild;
        }
      });
      const hasUpdatedChildren = prevProps.children.length !== this.props.children.length || checkUpdatedChildren(prevProps.children, this.props.children) || this.props.isGrouped && Array.from(prevProps.children).some((prevChild, index) => prevChild.type === SelectGroup && prevChild.props.children && this.props.children[index].props.children && (prevChild.props.children.length !== this.props.children[index].props.children.length || checkUpdatedChildren(prevChild.props.children, this.props.children[index].props.children)));
      if (hasUpdatedChildren) {
        this.updateTypeAheadFilteredChildren(prevState.typeaheadInputValue || "", null);
      }
      if (this.props.onFavorite && (this.props.favorites.length !== prevProps.favorites.length || this.state.typeaheadFilteredChildren !== prevState.typeaheadFilteredChildren)) {
        const tempRenderableChildren = this.props.variant === "typeahead" || this.props.variant === "typeaheadmulti" ? this.state.typeaheadFilteredChildren : this.props.children;
        const renderableFavorites = createRenderableFavorites(tempRenderableChildren, this.props.isGrouped, this.props.favorites);
        const favoritesGroup = renderableFavorites.length ? [
          React41.createElement(SelectGroup, { key: "favorites", label: this.props.favoritesLabel }, renderableFavorites),
          React41.createElement(Divider, { key: "favorites-group-divider" })
        ] : [];
        this.setState({ favoritesGroup });
      }
    };
    this.onEnter = () => {
      this.setState({ focusFirstOption: true });
    };
    this.onToggle = (isExpanded, e) => {
      const { isInputValuePersisted, onSelect, onToggle, hasInlineFilter } = this.props;
      if (!isExpanded && isInputValuePersisted && onSelect) {
        onSelect(void 0, this.inputRef.current ? this.inputRef.current.value : "");
      }
      if (isExpanded && hasInlineFilter) {
        this.setState({
          focusFirstOption: true
        });
      }
      onToggle(isExpanded, e);
    };
    this.onClose = () => {
      const { isInputFilterPersisted } = this.props;
      this.setState(Object.assign(Object.assign({ focusFirstOption: false, typeaheadInputValue: null }, !isInputFilterPersisted && {
        typeaheadFilteredChildren: React41.Children.toArray(this.props.children)
      }), { typeaheadCurrIndex: -1, tabbedIntoFavoritesMenu: false, viewMoreNextIndex: -1 }));
    };
    this.onChange = (e) => {
      if (e.target.value.toString() !== "" && !this.props.isOpen) {
        this.onToggle(true, e);
      }
      if (this.props.onTypeaheadInputChanged) {
        this.props.onTypeaheadInputChanged(e.target.value.toString());
      }
      this.setState({
        typeaheadCurrIndex: -1,
        typeaheadInputValue: e.target.value,
        creatableValue: e.target.value
      });
      this.updateTypeAheadFilteredChildren(e.target.value.toString(), e);
      this.refCollection = [[]];
    };
    this.updateTypeAheadFilteredChildren = (typeaheadInputValue, e) => {
      let typeaheadFilteredChildren;
      const { onFilter, isCreatable, isCreateOptionOnTop, onCreateOption, createText, noResultsFoundText, children, isGrouped, isCreateSelectOptionObject, loadingVariant } = this.props;
      if (onFilter) {
        typeaheadFilteredChildren = onFilter(e, e ? e.target.value : typeaheadInputValue) || children;
      } else {
        let input;
        try {
          input = new RegExp(typeaheadInputValue.toString(), "i");
        } catch (err) {
          input = new RegExp(typeaheadInputValue.toString().replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "i");
        }
        const childrenArray = React41.Children.toArray(children);
        if (isGrouped) {
          const childFilter = (child) => child.props.value && child.props.value.toString && this.getDisplay(child.props.value.toString(), "text").search(input) === 0;
          typeaheadFilteredChildren = typeaheadInputValue.toString() !== "" ? React41.Children.map(children, (group) => {
            if (React41.isValidElement(group) && group.type === SelectGroup) {
              const filteredGroupChildren = React41.Children.toArray(group.props.children).filter(childFilter);
              if (filteredGroupChildren.length > 0) {
                return React41.cloneElement(group, {
                  titleId: group.props.label && group.props.label.replace(/\W/g, "-"),
                  children: filteredGroupChildren
                });
              }
            } else {
              return React41.Children.toArray(group).filter(childFilter);
            }
          }) : childrenArray;
        } else {
          typeaheadFilteredChildren = typeaheadInputValue.toString() !== "" ? childrenArray.filter((child) => {
            const valueToCheck = child.props.value;
            if (!valueToCheck) {
              return true;
            }
            const isSelectOptionObject = typeof valueToCheck !== "string" && valueToCheck.toString && valueToCheck.compareTo;
            if (loadingVariant !== "spinner" && (loadingVariant === null || loadingVariant === void 0 ? void 0 : loadingVariant.text) === valueToCheck) {
              return true;
            }
            if (loadingVariant === "spinner" && valueToCheck === "loading") {
              return true;
            }
            if (isSelectOptionObject) {
              return valueToCheck.compareTo(typeaheadInputValue);
            } else {
              return this.getDisplay(child.props.value.toString(), "text").search(input) === 0;
            }
          }) : childrenArray;
        }
      }
      if (!typeaheadFilteredChildren) {
        typeaheadFilteredChildren = [];
      }
      if (typeaheadFilteredChildren.length === 0) {
        !isCreatable && typeaheadFilteredChildren.push(React41.createElement(SelectOption, { isDisabled: true, key: "no-results", value: noResultsFoundText, isNoResultsOption: true }));
      }
      if (isCreatable && typeaheadInputValue !== "") {
        const newValue = typeaheadInputValue;
        if (!typeaheadFilteredChildren.find((i) => i.props.value && i.props.value.toString().toLowerCase() === newValue.toString().toLowerCase())) {
          const newOptionValue = isCreateSelectOptionObject ? {
            toString: () => newValue,
            compareTo: (value) => this.toString().toLowerCase().includes(value.toString().toLowerCase())
          } : newValue;
          const createSelectOption = React41.createElement(
            SelectOption,
            { key: `create ${newValue}`, value: newOptionValue, onClick: () => onCreateOption && onCreateOption(newValue) },
            createText,
            ' "',
            newValue,
            '"'
          );
          if (isCreateOptionOnTop) {
            typeaheadFilteredChildren.unshift(createSelectOption);
          } else {
            typeaheadFilteredChildren.push(createSelectOption);
          }
        }
      }
      this.setState({
        typeaheadFilteredChildren
      });
    };
    this.onClick = (e) => {
      if (!this.props.isOpen) {
        this.onToggle(true, e);
      }
    };
    this.clearSelection = (_e) => {
      this.setState({
        typeaheadInputValue: null,
        typeaheadFilteredChildren: React41.Children.toArray(this.props.children),
        typeaheadCurrIndex: -1
      });
    };
    this.sendRef = (optionRef, favoriteRef, optionContainerRef, index) => {
      this.refCollection[index] = [optionRef, favoriteRef];
      this.optionContainerRefCollection[index] = optionContainerRef;
    };
    this.handleMenuKeys = (index, innerIndex, position) => {
      keyHandler(index, innerIndex, position, this.refCollection, this.refCollection);
      if (this.props.variant === SelectVariant.typeahead || this.props.variant === SelectVariant.typeaheadMulti) {
        if (position !== "tab") {
          this.handleTypeaheadKeys(position);
        }
      }
    };
    this.moveFocus = (nextIndex, updateCurrentIndex = true) => {
      const { isCreatable, createText } = this.props;
      const hasDescriptionElm = Boolean(this.refCollection[nextIndex][0] && this.refCollection[nextIndex][0].classList.contains("pf-m-description"));
      const isLoad = Boolean(this.refCollection[nextIndex][0] && this.refCollection[nextIndex][0].classList.contains("pf-m-load"));
      const optionTextElm = hasDescriptionElm ? this.refCollection[nextIndex][0].firstElementChild : this.refCollection[nextIndex][0];
      let typeaheadInputValue = "";
      if (isCreatable && optionTextElm.textContent.includes(createText)) {
        typeaheadInputValue = this.state.creatableValue;
      } else if (optionTextElm && !isLoad) {
        typeaheadInputValue = optionTextElm.textContent;
      }
      this.setState((prevState) => ({
        typeaheadCurrIndex: updateCurrentIndex ? nextIndex : prevState.typeaheadCurrIndex,
        typeaheadStoredIndex: nextIndex,
        typeaheadInputValue
      }));
    };
    this.switchFocusToFavoriteMenu = () => {
      const { typeaheadCurrIndex, typeaheadStoredIndex } = this.state;
      let indexForFocus = 0;
      if (typeaheadCurrIndex !== -1) {
        indexForFocus = typeaheadCurrIndex;
      } else if (typeaheadStoredIndex !== -1) {
        indexForFocus = typeaheadStoredIndex;
      }
      if (this.refCollection[indexForFocus] !== null && this.refCollection[indexForFocus][0] !== null) {
        this.refCollection[indexForFocus][0].focus();
      } else {
        this.clearRef.current.focus();
      }
      this.setState({
        tabbedIntoFavoritesMenu: true,
        typeaheadCurrIndex: -1
      });
    };
    this.moveFocusToLastMenuItem = () => {
      const refCollectionLen = this.refCollection.length;
      if (refCollectionLen > 0 && this.refCollection[refCollectionLen - 1] !== null && this.refCollection[refCollectionLen - 1][0] !== null) {
        this.refCollection[refCollectionLen - 1][0].focus();
      }
    };
    this.handleTypeaheadKeys = (position, shiftKey = false) => {
      const { isOpen, onFavorite, isCreatable } = this.props;
      const { typeaheadCurrIndex, tabbedIntoFavoritesMenu } = this.state;
      const typeaheadActiveChild = this.getTypeaheadActiveChild(typeaheadCurrIndex);
      if (isOpen) {
        if (position === "enter") {
          if ((typeaheadCurrIndex !== -1 || isCreatable && this.refCollection.length === 1) && // do not allow selection without moving to an initial option unless it is a single create option
          (typeaheadActiveChild || this.refCollection[0] && this.refCollection[0][0])) {
            if (typeaheadActiveChild) {
              if (!typeaheadActiveChild.classList.contains("pf-m-load")) {
                const hasDescriptionElm = typeaheadActiveChild.childElementCount > 1;
                const typeaheadActiveChildText = hasDescriptionElm ? typeaheadActiveChild.firstChild.textContent : typeaheadActiveChild.textContent;
                this.setState({
                  typeaheadInputValue: typeaheadActiveChildText
                });
              }
            } else if (this.refCollection[0] && this.refCollection[0][0]) {
              this.setState({
                typeaheadInputValue: this.refCollection[0][0].textContent
              });
            }
            if (typeaheadActiveChild) {
              typeaheadActiveChild.click();
            } else {
              this.refCollection[0][0].click();
            }
          }
        } else if (position === "tab") {
          if (onFavorite) {
            if (this.inputRef.current === document.activeElement) {
              if (this.props.footer && shiftKey) {
                const tabbableItems = findTabbableElements(this.footerRef, SelectFooterTabbableItems);
                if (tabbableItems.length > 0) {
                  if (tabbableItems[tabbableItems.length - 1]) {
                    tabbableItems[tabbableItems.length - 1].focus();
                  }
                }
              } else {
                this.switchFocusToFavoriteMenu();
              }
            } else {
              if (this.props.footer) {
                let tabbedIntoMenu = false;
                const tabbableItems = findTabbableElements(this.footerRef, SelectFooterTabbableItems);
                if (tabbableItems.length > 0) {
                  const currentElementIndex = tabbableItems.findIndex((item) => item === document.activeElement);
                  if (currentElementIndex === -1) {
                    if (shiftKey) {
                      this.inputRef.current.focus();
                    } else {
                      tabbableItems[0].focus();
                    }
                  } else {
                    if (shiftKey) {
                      if (currentElementIndex === 0) {
                        this.switchFocusToFavoriteMenu();
                        tabbedIntoMenu = true;
                      } else {
                        tabbableItems[currentElementIndex - 1].focus();
                      }
                    } else {
                      if (tabbableItems[currentElementIndex + 1]) {
                        tabbableItems[currentElementIndex + 1].focus();
                      } else {
                        this.inputRef.current.focus();
                      }
                    }
                  }
                } else {
                  this.inputRef.current.focus();
                  tabbedIntoMenu = false;
                }
                this.setState({ tabbedIntoFavoritesMenu: tabbedIntoMenu });
              } else {
                this.inputRef.current.focus();
                this.setState({ tabbedIntoFavoritesMenu: false });
              }
            }
          } else {
            if (!this.props.footer) {
              this.onToggle(false, null);
              this.onClose();
            } else {
              const tabbableItems = findTabbableElements(this.footerRef, SelectFooterTabbableItems);
              const currentElementIndex = tabbableItems.findIndex((item) => item === document.activeElement);
              if (this.inputRef.current === document.activeElement) {
                if (shiftKey) {
                  this.onToggle(false, null);
                  this.onClose();
                } else {
                  if (tabbableItems[0]) {
                    tabbableItems[0].focus();
                  } else {
                    this.onToggle(false, null);
                    this.onClose();
                  }
                }
              } else {
                if (shiftKey) {
                  if (currentElementIndex === 0) {
                    this.inputRef.current.focus();
                  } else {
                    tabbableItems[currentElementIndex - 1].focus();
                  }
                } else {
                  if (tabbableItems[currentElementIndex + 1]) {
                    tabbableItems[currentElementIndex + 1].focus();
                  } else {
                    this.onToggle(false, null);
                    this.inputRef.current.focus();
                    this.onClose();
                  }
                }
              }
            }
          }
        } else if (!tabbedIntoFavoritesMenu) {
          if (this.refCollection[0][0] === null) {
            return;
          }
          let nextIndex;
          if (typeaheadCurrIndex === -1 && position === "down") {
            nextIndex = 0;
          } else if (typeaheadCurrIndex === -1 && position === "up") {
            nextIndex = this.refCollection.length - 1;
          } else if (position !== "left" && position !== "right") {
            nextIndex = getNextIndex(typeaheadCurrIndex, position, this.refCollection);
          } else {
            nextIndex = typeaheadCurrIndex;
          }
          if (this.refCollection[nextIndex] === null) {
            return;
          }
          this.moveFocus(nextIndex);
        } else {
          const nextIndex = this.refCollection.findIndex((ref) => ref !== void 0 && (ref[0] === document.activeElement || ref[1] === document.activeElement));
          this.moveFocus(nextIndex);
        }
      }
    };
    this.onClickTypeaheadToggleButton = () => {
      if (this.inputRef && this.inputRef.current) {
        this.inputRef.current.focus();
      }
    };
    this.getDisplay = (value, type = "node") => {
      if (!value) {
        return;
      }
      const item = this.props.isGrouped ? React41.Children.toArray(this.props.children).reduce((acc, curr) => [...acc, ...React41.Children.toArray(curr.props.children)], []).find((child) => child.props.value.toString() === value.toString()) : React41.Children.toArray(this.props.children).find((child) => child.props.value && child.props.value.toString() === value.toString());
      if (item) {
        if (item && item.props.children) {
          if (type === "node") {
            return item.props.children;
          }
          return this.findText(item);
        }
        return item.props.value.toString();
      }
      return value.toString();
    };
    this.findText = (item) => {
      if (typeof item === "string") {
        return item;
      } else if (!React41.isValidElement(item)) {
        return "";
      } else {
        const multi = [];
        React41.Children.toArray(item.props.children).forEach((child) => multi.push(this.findText(child)));
        return multi.join("");
      }
    };
    this.generateSelectedBadge = () => {
      const { customBadgeText, selections } = this.props;
      if (customBadgeText !== null) {
        return customBadgeText;
      }
      if (Array.isArray(selections) && selections.length > 0) {
        return selections.length;
      }
      return null;
    };
    this.setVieMoreNextIndex = () => {
      this.setState({ viewMoreNextIndex: this.refCollection.length - 1 });
    };
    this.isLastOptionBeforeFooter = (index) => this.props.footer && index === this.refCollection.length - 1 ? true : false;
  }
  extendTypeaheadChildren(typeaheadCurrIndex, favoritesGroup) {
    const { isGrouped, onFavorite, createText } = this.props;
    const typeaheadChildren = favoritesGroup ? favoritesGroup.concat(this.state.typeaheadFilteredChildren) : this.state.typeaheadFilteredChildren;
    const activeElement = this.optionContainerRefCollection[typeaheadCurrIndex];
    let typeaheadActiveChild = this.getTypeaheadActiveChild(typeaheadCurrIndex);
    if (typeaheadActiveChild && typeaheadActiveChild.classList.contains("pf-m-description")) {
      typeaheadActiveChild = typeaheadActiveChild.firstElementChild;
    }
    this.refCollection = [[]];
    this.optionContainerRefCollection = [];
    if (isGrouped) {
      return React41.Children.map(typeaheadChildren, (group) => {
        if (group.type === Divider) {
          return group;
        } else if (group.type === SelectGroup && onFavorite) {
          return React41.cloneElement(group, {
            titleId: group.props.label && group.props.label.replace(/\W/g, "-"),
            children: React41.Children.map(group.props.children, (child) => child.type === Divider ? child : React41.cloneElement(child, {
              isFocused: activeElement && (activeElement.id === child.props.id || this.props.isCreatable && typeaheadActiveChild.textContent === `${createText} "${group.props.value}"`)
            }))
          });
        } else if (group.type === SelectGroup) {
          return React41.cloneElement(group, {
            titleId: group.props.label && group.props.label.replace(/\W/g, "-"),
            children: React41.Children.map(group.props.children, (child) => child.type === Divider ? child : React41.cloneElement(child, {
              isFocused: typeaheadActiveChild && (typeaheadActiveChild.textContent === child.props.value.toString() || this.props.isCreatable && typeaheadActiveChild.textContent === `${createText} "${child.props.value}"`)
            }))
          });
        } else {
          return React41.cloneElement(group, {
            isFocused: typeaheadActiveChild && (typeaheadActiveChild.textContent === group.props.value.toString() || this.props.isCreatable && typeaheadActiveChild.textContent === `${createText} "${group.props.value}"`)
          });
        }
      });
    }
    return typeaheadChildren.map((child, index) => {
      const childElement = child;
      return childElement.type.displayName === "Divider" ? child : React41.cloneElement(child, {
        isFocused: typeaheadActiveChild ? typeaheadActiveChild.textContent === child.props.value.toString() || this.props.isCreatable && typeaheadActiveChild.textContent === `${createText} "${child.props.value}"` : index === typeaheadCurrIndex
        // fallback for view more + typeahead use cases, when the new expanded list is loaded and refCollection hasn't be updated yet
      });
    });
  }
  render() {
    const _a = this.props, {
      children,
      chipGroupProps,
      chipGroupComponent,
      className,
      customContent,
      variant,
      direction,
      onSelect,
      onClear,
      onBlur,
      toggleId,
      toggleRef,
      isOpen,
      isGrouped,
      isPlain,
      isDisabled,
      hasPlaceholderStyle,
      validated,
      selections: selectionsProp,
      typeAheadAriaLabel,
      typeAheadAriaDescribedby,
      clearSelectionsAriaLabel,
      toggleAriaLabel,
      removeSelectionAriaLabel,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      "aria-describedby": ariaDescribedby,
      "aria-invalid": ariaInvalid,
      placeholderText,
      width,
      maxHeight,
      toggleIcon,
      toggleIndicator,
      ouiaId,
      ouiaSafe,
      hasInlineFilter,
      isCheckboxSelectionBadgeHidden,
      inlineFilterPlaceholderText,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      onFilter,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      onTypeaheadInputChanged,
      onCreateOption,
      isCreatable,
      onToggle,
      createText,
      noResultsFoundText,
      customBadgeText,
      inputIdPrefix,
      inputAutoComplete,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      isInputValuePersisted,
      isInputFilterPersisted,
      /* eslint-enable @typescript-eslint/no-unused-vars */
      menuAppendTo,
      favorites,
      onFavorite,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      favoritesLabel,
      footer,
      loadingVariant,
      isCreateSelectOptionObject,
      isCreateOptionOnTop,
      shouldResetOnSelect,
      isFlipEnabled,
      removeFindDomNode,
      zIndex
    } = _a, props = __rest(_a, ["children", "chipGroupProps", "chipGroupComponent", "className", "customContent", "variant", "direction", "onSelect", "onClear", "onBlur", "toggleId", "toggleRef", "isOpen", "isGrouped", "isPlain", "isDisabled", "hasPlaceholderStyle", "validated", "selections", "typeAheadAriaLabel", "typeAheadAriaDescribedby", "clearSelectionsAriaLabel", "toggleAriaLabel", "removeSelectionAriaLabel", "aria-label", "aria-labelledby", "aria-describedby", "aria-invalid", "placeholderText", "width", "maxHeight", "toggleIcon", "toggleIndicator", "ouiaId", "ouiaSafe", "hasInlineFilter", "isCheckboxSelectionBadgeHidden", "inlineFilterPlaceholderText", "onFilter", "onTypeaheadInputChanged", "onCreateOption", "isCreatable", "onToggle", "createText", "noResultsFoundText", "customBadgeText", "inputIdPrefix", "inputAutoComplete", "isInputValuePersisted", "isInputFilterPersisted", "menuAppendTo", "favorites", "onFavorite", "favoritesLabel", "footer", "loadingVariant", "isCreateSelectOptionObject", "isCreateOptionOnTop", "shouldResetOnSelect", "isFlipEnabled", "removeFindDomNode", "zIndex"]);
    const { focusFirstOption: openedOnEnter, typeaheadCurrIndex, typeaheadInputValue, typeaheadFilteredChildren, favoritesGroup } = this.state;
    const selectToggleId = toggleId || `pf-select-toggle-id-${currentId2++}`;
    const selections = Array.isArray(selectionsProp) ? selectionsProp : [selectionsProp];
    const selectedOption = React41.Children.toArray(children).find((option) => option.props.value === selections[0]);
    const isSelectedPlaceholder = selectedOption && selectedOption.props.isPlaceholder;
    const hasAnySelections = Boolean(selections[0] && selections[0] !== "");
    const typeaheadActiveChild = this.getTypeaheadActiveChild(typeaheadCurrIndex);
    let childPlaceholderText = null;
    let renderableItems = [];
    if (onFavorite) {
      let tempExtendedChildren = children;
      if (variant === "typeahead" || variant === "typeaheadmulti") {
        tempExtendedChildren = this.extendTypeaheadChildren(typeaheadCurrIndex, favoritesGroup);
      } else if (onFavorite) {
        tempExtendedChildren = favoritesGroup.concat(children);
      }
      renderableItems = extendItemsWithFavorite(tempExtendedChildren, isGrouped, favorites);
    } else {
      renderableItems = children;
    }
    if (!customContent) {
      if (!hasAnySelections && !placeholderText) {
        const childPlaceholder = React41.Children.toArray(children).filter((child) => child.props.isPlaceholder === true);
        childPlaceholderText = childPlaceholder[0] && this.getDisplay(childPlaceholder[0].props.value, "node") || children[0] && this.getDisplay(children[0].props.value, "node");
      }
    }
    if (isOpen) {
      if (renderableItems.find((item) => (item === null || item === void 0 ? void 0 : item.key) === "loading") === void 0) {
        if (loadingVariant === "spinner") {
          renderableItems.push(React41.createElement(
            SelectOption,
            { isLoading: true, key: "loading", value: "loading" },
            React41.createElement(Spinner, { size: "lg" })
          ));
        } else if (loadingVariant === null || loadingVariant === void 0 ? void 0 : loadingVariant.text) {
          renderableItems.push(React41.createElement(SelectOption, { isLoad: true, key: "loading", value: loadingVariant.text, setViewMoreNextIndex: this.setVieMoreNextIndex, onClick: loadingVariant === null || loadingVariant === void 0 ? void 0 : loadingVariant.onClick }));
        }
      }
    }
    const hasOnClear = onClear !== _Select.defaultProps.onClear;
    const clearBtn = React41.createElement(
      "button",
      { className: css(button_default.button, button_default.modifiers.plain, select_default.selectToggleClear), onClick: (e) => {
        this.clearSelection(e);
        onClear(e);
        e.stopPropagation();
      }, "aria-label": clearSelectionsAriaLabel, type: "button", disabled: isDisabled, ref: this.clearRef, onKeyDown: (event) => {
        if (event.key === KeyTypes.Enter) {
          this.clearRef.current.click();
        }
      } },
      React41.createElement(times_circle_icon_default, { "aria-hidden": true })
    );
    let selectedChips = null;
    if (variant === SelectVariant.typeaheadMulti) {
      selectedChips = chipGroupComponent ? chipGroupComponent : React41.createElement(ChipGroup, Object.assign({}, chipGroupProps), selections && selections.map((item) => React41.createElement(Chip, { key: item, onClick: (e) => onSelect(e, item), closeBtnAriaLabel: removeSelectionAriaLabel }, this.getDisplay(item, "node"))));
    }
    if (hasInlineFilter) {
      const filterBox = React41.createElement(
        React41.Fragment,
        null,
        React41.createElement(
          "div",
          { key: "inline-filter", className: css(select_default.selectMenuSearch) },
          React41.createElement("input", { key: "inline-filter-input", type: "search", className: css(form_control_default.formControl, form_control_default.modifiers.search), onChange: this.onChange, placeholder: inlineFilterPlaceholderText, onKeyDown: (event) => {
            if (event.key === KeyTypes.ArrowUp) {
              this.handleMenuKeys(0, 0, "up");
              event.preventDefault();
            } else if (event.key === KeyTypes.ArrowDown) {
              this.handleMenuKeys(0, 0, "down");
              event.preventDefault();
            } else if (event.key === KeyTypes.ArrowLeft) {
              this.handleMenuKeys(0, 0, "left");
              event.preventDefault();
            } else if (event.key === KeyTypes.ArrowRight) {
              this.handleMenuKeys(0, 0, "right");
              event.preventDefault();
            } else if (event.key === KeyTypes.Tab && variant !== SelectVariant.checkbox && this.props.footer) {
              if (event.shiftKey) {
                this.onToggle(false, event);
              } else {
                const tabbableItems = findTabbableElements(this.footerRef, SelectFooterTabbableItems);
                if (tabbableItems.length > 0) {
                  tabbableItems[0].focus();
                  event.stopPropagation();
                  event.preventDefault();
                } else {
                  this.onToggle(false, event);
                }
              }
            } else if (event.key === KeyTypes.Tab && variant === SelectVariant.checkbox) {
              if (event.shiftKey) {
                this.handleMenuKeys(0, 0, "up");
              } else {
                this.handleMenuKeys(0, 0, "down");
              }
              event.stopPropagation();
              event.preventDefault();
            }
          }, ref: this.filterRef, autoComplete: inputAutoComplete })
        ),
        React41.createElement(Divider, { key: "inline-filter-divider" })
      );
      renderableItems = [filterBox, ...typeaheadFilteredChildren].map((option, index) => React41.cloneElement(option, { key: index }));
    }
    let variantProps;
    let variantChildren;
    if (customContent) {
      variantProps = {
        selected: selections,
        openedOnEnter,
        isCustomContent: true
      };
      variantChildren = customContent;
    } else {
      switch (variant) {
        case "single":
          variantProps = {
            selected: selections[0],
            hasInlineFilter,
            openedOnEnter
          };
          variantChildren = renderableItems;
          break;
        case "checkbox":
          variantProps = {
            checked: selections,
            isGrouped,
            hasInlineFilter,
            openedOnEnter
          };
          variantChildren = renderableItems;
          break;
        case "typeahead":
          variantProps = {
            selected: selections[0],
            openedOnEnter
          };
          variantChildren = onFavorite ? renderableItems : this.extendTypeaheadChildren(typeaheadCurrIndex);
          if (variantChildren.length === 0) {
            variantChildren.push(React41.createElement(SelectOption, { isDisabled: true, key: 0, value: noResultsFoundText, isNoResultsOption: true }));
          }
          break;
        case "typeaheadmulti":
          variantProps = {
            selected: selections,
            openedOnEnter
          };
          variantChildren = onFavorite ? renderableItems : this.extendTypeaheadChildren(typeaheadCurrIndex);
          if (variantChildren.length === 0) {
            variantChildren.push(React41.createElement(SelectOption, { isDisabled: true, key: 0, value: noResultsFoundText, isNoResultsOption: true }));
          }
          break;
      }
    }
    const isStatic = isFlipEnabled && menuAppendTo !== "inline";
    const innerMenu = React41.createElement(SelectMenu, Object.assign({ className: css(isStatic && select_default.modifiers.static) }, props, { isGrouped, selected: selections }, variantProps, { openedOnEnter, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, sendRef: this.sendRef, keyHandler: this.handleMenuKeys, maxHeight, ref: this.menuComponentRef, footer, footerRef: this.footerRef, isLastOptionBeforeFooter: this.isLastOptionBeforeFooter }), variantChildren);
    const menuContainer = footer ? React41.createElement(
      "div",
      { className: css(select_default.selectMenu) },
      " ",
      innerMenu,
      " "
    ) : innerMenu;
    const popperContainer = React41.createElement("div", Object.assign({ className: css(select_default.select, isOpen && select_default.modifiers.expanded, validated === ValidatedOptions.success && select_default.modifiers.success, validated === ValidatedOptions.warning && select_default.modifiers.warning, validated === ValidatedOptions.error && select_default.modifiers.invalid, direction === SelectDirection.up && select_default.modifiers.top, className) }, width && { style: { width } }, validated !== ValidatedOptions.default && { "aria-invalid": ariaInvalid }), isOpen && menuContainer);
    const mainContainer = React41.createElement(
      "div",
      Object.assign({ className: css(select_default.select, isOpen && select_default.modifiers.expanded, validated === ValidatedOptions.success && select_default.modifiers.success, validated === ValidatedOptions.warning && select_default.modifiers.warning, validated === ValidatedOptions.error && select_default.modifiers.invalid, direction === SelectDirection.up && select_default.modifiers.top, className), ref: this.parentRef }, getOUIAProps(_Select.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe), width && { style: { width } }, validated !== ValidatedOptions.default && { "aria-invalid": ariaInvalid }),
      React41.createElement(
        SelectToggle,
        Object.assign({ id: selectToggleId, parentRef: this.parentRef, menuRef: this.menuComponentRef, ref: toggleRef }, footer && { footerRef: this.footerRef }, { isOpen, isPlain, hasPlaceholderStyle: hasPlaceholderStyle && (!selections.length || selections[0] === null || isSelectedPlaceholder), onToggle: this.onToggle, onEnter: this.onEnter, onClose: this.onClose, onBlur, variant, toggleIndicator, "aria-labelledby": `${ariaLabelledBy || ""} ${selectToggleId}`, "aria-label": toggleAriaLabel }, ariaDescribedby && { "aria-describedby": ariaDescribedby }, { handleTypeaheadKeys: this.handleTypeaheadKeys, moveFocusToLastMenuItem: this.moveFocusToLastMenuItem, isDisabled, hasClearButton: hasOnClear, hasFooter: footer !== void 0, onClickTypeaheadToggleButton: this.onClickTypeaheadToggleButton }),
        customContent && React41.createElement(
          "div",
          { className: css(select_default.selectToggleWrapper) },
          toggleIcon && React41.createElement("span", { className: css(select_default.selectToggleIcon) }, toggleIcon),
          React41.createElement("span", { className: css(select_default.selectToggleText) }, placeholderText)
        ),
        variant === SelectVariant.single && !customContent && React41.createElement(
          React41.Fragment,
          null,
          React41.createElement(
            "div",
            { className: css(select_default.selectToggleWrapper) },
            toggleIcon && React41.createElement("span", { className: css(select_default.selectToggleIcon) }, toggleIcon),
            React41.createElement("span", { className: css(select_default.selectToggleText) }, this.getDisplay(selections[0], "node") || placeholderText || childPlaceholderText)
          ),
          hasOnClear && hasAnySelections && clearBtn
        ),
        variant === SelectVariant.checkbox && !customContent && React41.createElement(
          React41.Fragment,
          null,
          React41.createElement(
            "div",
            { className: css(select_default.selectToggleWrapper) },
            toggleIcon && React41.createElement("span", { className: css(select_default.selectToggleIcon) }, toggleIcon),
            React41.createElement("span", { className: css(select_default.selectToggleText) }, placeholderText),
            !isCheckboxSelectionBadgeHidden && hasAnySelections && React41.createElement(
              "div",
              { className: css(select_default.selectToggleBadge) },
              React41.createElement("span", { className: css(badge_default.badge, badge_default.modifiers.read) }, this.generateSelectedBadge())
            )
          ),
          hasOnClear && hasAnySelections && clearBtn
        ),
        variant === SelectVariant.typeahead && !customContent && React41.createElement(
          React41.Fragment,
          null,
          React41.createElement(
            "div",
            { className: css(select_default.selectToggleWrapper) },
            toggleIcon && React41.createElement("span", { className: css(select_default.selectToggleIcon) }, toggleIcon),
            React41.createElement("input", Object.assign({ className: css(form_control_default.formControl, select_default.selectToggleTypeahead), "aria-activedescendant": typeaheadActiveChild && typeaheadActiveChild.id, id: `${selectToggleId}-select-typeahead`, "aria-label": typeAheadAriaLabel }, typeAheadAriaDescribedby && { "aria-describedby": typeAheadAriaDescribedby }, { placeholder: placeholderText, value: typeaheadInputValue !== null ? typeaheadInputValue : this.getDisplay(selections[0], "text") || "", type: "text", onClick: this.onClick, onChange: this.onChange, autoComplete: inputAutoComplete, disabled: isDisabled, ref: this.inputRef }))
          ),
          hasOnClear && (selections[0] || typeaheadInputValue) && clearBtn
        ),
        variant === SelectVariant.typeaheadMulti && !customContent && React41.createElement(
          React41.Fragment,
          null,
          React41.createElement(
            "div",
            { className: css(select_default.selectToggleWrapper) },
            toggleIcon && React41.createElement("span", { className: css(select_default.selectToggleIcon) }, toggleIcon),
            selections && Array.isArray(selections) && selections.length > 0 && selectedChips,
            React41.createElement("input", Object.assign({ className: css(form_control_default.formControl, select_default.selectToggleTypeahead), "aria-activedescendant": typeaheadActiveChild && typeaheadActiveChild.id, id: `${selectToggleId}-select-multi-typeahead-typeahead`, "aria-label": typeAheadAriaLabel, "aria-invalid": validated === ValidatedOptions.error }, typeAheadAriaDescribedby && { "aria-describedby": typeAheadAriaDescribedby }, { placeholder: placeholderText, value: typeaheadInputValue !== null ? typeaheadInputValue : "", type: "text", onChange: this.onChange, onClick: this.onClick, autoComplete: inputAutoComplete, disabled: isDisabled, ref: this.inputRef }))
          ),
          hasOnClear && (selections && selections.length > 0 || typeaheadInputValue) && clearBtn
        ),
        validated === ValidatedOptions.success && React41.createElement(
          "span",
          { className: css(select_default.selectToggleStatusIcon) },
          React41.createElement(check_circle_icon_default, { "aria-hidden": "true" })
        ),
        validated === ValidatedOptions.error && React41.createElement(
          "span",
          { className: css(select_default.selectToggleStatusIcon) },
          React41.createElement(exclamation_circle_icon_default, { "aria-hidden": "true" })
        ),
        validated === ValidatedOptions.warning && React41.createElement(
          "span",
          { className: css(select_default.selectToggleStatusIcon) },
          React41.createElement(exclamation_triangle_icon_default, { "aria-hidden": "true" })
        )
      ),
      isOpen && menuAppendTo === "inline" && menuContainer
    );
    const getParentElement = () => {
      if (this.parentRef && this.parentRef.current) {
        return this.parentRef.current.parentElement;
      }
      return null;
    };
    return React41.createElement(GenerateId, null, (randomId) => React41.createElement(SelectContext.Provider, { value: {
      onSelect,
      onFavorite,
      onClose: this.onClose,
      variant,
      inputIdPrefix: inputIdPrefix || randomId,
      shouldResetOnSelect
    } }, menuAppendTo === "inline" ? mainContainer : React41.createElement(Popper, { trigger: mainContainer, popper: popperContainer, direction, appendTo: menuAppendTo === "parent" ? getParentElement() : menuAppendTo, isVisible: isOpen, removeFindDomNode, zIndex })));
  }
};
Select.displayName = "Select";
Select.defaultProps = {
  children: [],
  className: "",
  position: SelectPosition.left,
  direction: SelectDirection.down,
  toggleId: null,
  isOpen: false,
  isGrouped: false,
  isPlain: false,
  isDisabled: false,
  hasPlaceholderStyle: false,
  isCreatable: false,
  isCreateOptionOnTop: false,
  validated: "default",
  "aria-label": "",
  "aria-labelledby": "",
  "aria-describedby": "",
  "aria-invalid": false,
  typeAheadAriaLabel: "",
  typeAheadAriaDescribedby: "",
  clearSelectionsAriaLabel: "Clear all",
  toggleAriaLabel: "Options menu",
  removeSelectionAriaLabel: "Remove",
  selections: [],
  createText: "Create",
  placeholderText: "",
  noResultsFoundText: "No results found",
  variant: SelectVariant.single,
  width: "",
  onClear: () => void 0,
  onCreateOption: () => void 0,
  toggleIcon: null,
  toggleIndicator: null,
  onFilter: null,
  onTypeaheadInputChanged: null,
  customContent: null,
  hasInlineFilter: false,
  inlineFilterPlaceholderText: null,
  customBadgeText: null,
  inputIdPrefix: "",
  inputAutoComplete: "off",
  menuAppendTo: "inline",
  favorites: [],
  favoritesLabel: "Favorites",
  ouiaSafe: true,
  chipGroupComponent: null,
  isInputValuePersisted: false,
  isInputFilterPersisted: false,
  isCreateSelectOptionObject: false,
  shouldResetOnSelect: true,
  isFlipEnabled: true,
  removeFindDomNode: false,
  zIndex: 9999
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Checkbox/Checkbox.js
var React42 = __toESM(require_react());
var defaultOnChange = () => {
};
var Checkbox = class _Checkbox extends React42.Component {
  constructor(props) {
    super(props);
    this.handleChange = (event) => {
      this.props.onChange(event.currentTarget.checked, event);
    };
    this.state = {
      ouiaStateId: getDefaultOUIAId(_Checkbox.displayName)
    };
  }
  render() {
    const _a = this.props, { "aria-label": ariaLabel, className, onChange, isValid, isDisabled, isRequired, isChecked, label, checked, defaultChecked, description, body, ouiaId, ouiaSafe, component: Component19 } = _a, props = __rest(_a, ["aria-label", "className", "onChange", "isValid", "isDisabled", "isRequired", "isChecked", "label", "checked", "defaultChecked", "description", "body", "ouiaId", "ouiaSafe", "component"]);
    if (!props.id) {
      console.error("Checkbox:", "id is required to make input accessible");
    }
    const checkedProps = {};
    if ([true, false].includes(checked) || isChecked === true) {
      checkedProps.checked = checked || isChecked;
    }
    if (onChange !== defaultOnChange) {
      checkedProps.checked = isChecked;
    }
    if ([false, true].includes(defaultChecked)) {
      checkedProps.defaultChecked = defaultChecked;
    }
    checkedProps.checked = checkedProps.checked === null ? false : checkedProps.checked;
    return React42.createElement(
      Component19,
      { className: css(check_default.check, !label && check_default.modifiers.standalone, className) },
      React42.createElement("input", Object.assign({}, props, { className: css(check_default.checkInput), type: "checkbox", onChange: this.handleChange, "aria-invalid": !isValid, "aria-label": ariaLabel, disabled: isDisabled, required: isRequired, ref: (elem) => elem && (elem.indeterminate = isChecked === null) }, checkedProps, getOUIAProps(_Checkbox.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe))),
      label && React42.createElement(
        "label",
        { className: css(check_default.checkLabel, isDisabled && check_default.modifiers.disabled), htmlFor: props.id },
        label,
        isRequired && React42.createElement("span", { className: css(check_default.checkLabelRequired), "aria-hidden": "true" }, ASTERISK)
      ),
      description && React42.createElement("span", { className: css(check_default.checkDescription) }, description),
      body && React42.createElement("span", { className: css(check_default.checkBody) }, body)
    );
  }
};
Checkbox.displayName = "Checkbox";
Checkbox.defaultProps = {
  className: "",
  isValid: true,
  isDisabled: false,
  isRequired: false,
  isChecked: false,
  onChange: defaultOnChange,
  ouiaSafe: true,
  component: "div"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Popover/Popover.js
var React52 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Popover/popover.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/Popover/popover.css";
var popover_default = {
  "button": "pf-c-button",
  "modifiers": {
    "noPadding": "pf-m-no-padding",
    "widthAuto": "pf-m-width-auto",
    "top": "pf-m-top",
    "topLeft": "pf-m-top-left",
    "topRight": "pf-m-top-right",
    "bottom": "pf-m-bottom",
    "bottomLeft": "pf-m-bottom-left",
    "bottomRight": "pf-m-bottom-right",
    "left": "pf-m-left",
    "leftTop": "pf-m-left-top",
    "leftBottom": "pf-m-left-bottom",
    "right": "pf-m-right",
    "rightTop": "pf-m-right-top",
    "rightBottom": "pf-m-right-bottom",
    "danger": "pf-m-danger",
    "warning": "pf-m-warning",
    "success": "pf-m-success",
    "default": "pf-m-default",
    "info": "pf-m-info",
    "icon": "pf-m-icon"
  },
  "popover": "pf-c-popover",
  "popoverArrow": "pf-c-popover__arrow",
  "popoverBody": "pf-c-popover__body",
  "popoverContent": "pf-c-popover__content",
  "popoverFooter": "pf-c-popover__footer",
  "popoverTitle": "pf-c-popover__title",
  "popoverTitleIcon": "pf-c-popover__title-icon",
  "popoverTitleText": "pf-c-popover__title-text",
  "themeDark": "pf-theme-dark",
  "title": "pf-c-title"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverContext.js
var React43 = __toESM(require_react());
var PopoverContext = React43.createContext({});

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverContent.js
var React44 = __toESM(require_react());
var PopoverContent = (_a) => {
  var { className = null, children } = _a, props = __rest(_a, ["className", "children"]);
  return React44.createElement("div", Object.assign({ className: css(popover_default.popoverContent, className) }, props), children);
};
PopoverContent.displayName = "PopoverContent";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverBody.js
var React45 = __toESM(require_react());
var PopoverBody = (_a) => {
  var { children, id, className } = _a, props = __rest(_a, ["children", "id", "className"]);
  return React45.createElement("div", Object.assign({ className: css(popover_default.popoverBody, className), id }, props), children);
};
PopoverBody.displayName = "PopoverBody";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverHeader.js
var React48 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverHeaderIcon.js
var React46 = __toESM(require_react());
var PopoverHeaderIcon = (_a) => {
  var { children, className } = _a, props = __rest(_a, ["children", "className"]);
  return React46.createElement("span", Object.assign({ className: css(popover_default.popoverTitleIcon, className) }, props), children);
};
PopoverHeaderIcon.displayName = "PopoverHeaderIcon";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverHeaderText.js
var React47 = __toESM(require_react());
var PopoverHeaderText = (_a) => {
  var { children, className } = _a, props = __rest(_a, ["children", "className"]);
  return React47.createElement("span", Object.assign({ className: css(popover_default.popoverTitleText, className) }, props), children);
};
PopoverHeaderText.displayName = "PopoverHeaderText";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverHeader.js
var PopoverHeader = (_a) => {
  var { children, icon, className, titleHeadingLevel = "h6", alertSeverityVariant, id, alertSeverityScreenReaderText } = _a, props = __rest(_a, ["children", "icon", "className", "titleHeadingLevel", "alertSeverityVariant", "id", "alertSeverityScreenReaderText"]);
  const HeadingLevel = titleHeadingLevel;
  return icon || alertSeverityVariant ? React48.createElement(
    "header",
    Object.assign({ className: css("pf-c-popover__header", className), id }, props),
    React48.createElement(
      HeadingLevel,
      { className: css(popover_default.popoverTitle, icon && popover_default.modifiers.icon) },
      icon && React48.createElement(PopoverHeaderIcon, null, icon),
      alertSeverityVariant && alertSeverityScreenReaderText && React48.createElement("span", { className: "pf-u-screen-reader" }, alertSeverityScreenReaderText),
      React48.createElement(PopoverHeaderText, null, children)
    )
  ) : React48.createElement(Title, Object.assign({ headingLevel: titleHeadingLevel, size: TitleSizes.md, id, className }, props), children);
};
PopoverHeader.displayName = "PopoverHeader";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverFooter.js
var React49 = __toESM(require_react());
var PopoverFooter = (_a) => {
  var { children, className = "" } = _a, props = __rest(_a, ["children", "className"]);
  return React49.createElement("footer", Object.assign({ className: css(popover_default.popoverFooter, className) }, props), children);
};
PopoverFooter.displayName = "PopoverFooter";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverCloseButton.js
var React50 = __toESM(require_react());
var PopoverCloseButton = (_a) => {
  var { onClose = () => void 0 } = _a, props = __rest(_a, ["onClose"]);
  return React50.createElement(
    Button,
    Object.assign({ onClick: onClose, variant: "plain", "aria-label": true }, props, { style: { pointerEvents: "auto" } }),
    React50.createElement(times_icon_default, null)
  );
};
PopoverCloseButton.displayName = "PopoverCloseButton";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverArrow.js
var React51 = __toESM(require_react());
var PopoverArrow = (_a) => {
  var { className = "" } = _a, props = __rest(_a, ["className"]);
  return React51.createElement("div", Object.assign({ className: css(popover_default.popoverArrow, className) }, props));
};
PopoverArrow.displayName = "PopoverArrow";

// ../../node_modules/.pnpm/@patternfly+react-tokens@4.94.7/node_modules/@patternfly/react-tokens/dist/esm/c_popover_MaxWidth.js
var c_popover_MaxWidth = {
  "name": "--pf-c-popover--MaxWidth",
  "value": "none",
  "var": "var(--pf-c-popover--MaxWidth)"
};
var c_popover_MaxWidth_default = c_popover_MaxWidth;

// ../../node_modules/.pnpm/@patternfly+react-tokens@4.94.7/node_modules/@patternfly/react-tokens/dist/esm/c_popover_MinWidth.js
var c_popover_MinWidth = {
  "name": "--pf-c-popover--MinWidth",
  "value": "auto",
  "var": "var(--pf-c-popover--MinWidth)"
};
var c_popover_MinWidth_default = c_popover_MinWidth;

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/Popover/Popover.js
var PopoverPosition;
(function(PopoverPosition2) {
  PopoverPosition2["auto"] = "auto";
  PopoverPosition2["top"] = "top";
  PopoverPosition2["bottom"] = "bottom";
  PopoverPosition2["left"] = "left";
  PopoverPosition2["right"] = "right";
  PopoverPosition2["topStart"] = "top-start";
  PopoverPosition2["topEnd"] = "top-end";
  PopoverPosition2["bottomStart"] = "bottom-start";
  PopoverPosition2["bottomEnd"] = "bottom-end";
  PopoverPosition2["leftStart"] = "left-start";
  PopoverPosition2["leftEnd"] = "left-end";
  PopoverPosition2["rightStart"] = "right-start";
  PopoverPosition2["rightEnd"] = "right-end";
})(PopoverPosition || (PopoverPosition = {}));
var alertStyle = {
  default: popover_default.modifiers.default,
  info: popover_default.modifiers.info,
  success: popover_default.modifiers.success,
  warning: popover_default.modifiers.warning,
  danger: popover_default.modifiers.danger
};
var Popover = (_a) => {
  var { children, position = "top", enableFlip = true, className = "", isVisible = null, shouldClose = () => null, shouldOpen = () => null, "aria-label": ariaLabel = "", bodyContent, headerContent = null, headerComponent = "h6", headerIcon = null, alertSeverityVariant, alertSeverityScreenReaderText, footerContent = null, appendTo = () => document.body, hideOnOutsideClick = true, onHide = () => null, onHidden = () => null, onShow = () => null, onShown = () => null, onMount = () => null, zIndex = 9999, minWidth = c_popover_MinWidth_default && c_popover_MinWidth_default.value, maxWidth = c_popover_MaxWidth_default && c_popover_MaxWidth_default.value, closeBtnAriaLabel = "Close", showClose = true, distance = 25, flipBehavior = [
    "top",
    "bottom",
    "left",
    "right",
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-start",
    "left-end",
    "right-start",
    "right-end"
  ], animationDuration = 300, id, withFocusTrap: propWithFocusTrap, boundary, tippyProps, reference: reference2, hasNoPadding = false, hasAutoWidth = false, removeFindDomNode = false } = _a, rest = __rest(_a, ["children", "position", "enableFlip", "className", "isVisible", "shouldClose", "shouldOpen", "aria-label", "bodyContent", "headerContent", "headerComponent", "headerIcon", "alertSeverityVariant", "alertSeverityScreenReaderText", "footerContent", "appendTo", "hideOnOutsideClick", "onHide", "onHidden", "onShow", "onShown", "onMount", "zIndex", "minWidth", "maxWidth", "closeBtnAriaLabel", "showClose", "distance", "flipBehavior", "animationDuration", "id", "withFocusTrap", "boundary", "tippyProps", "reference", "hasNoPadding", "hasAutoWidth", "removeFindDomNode"]);
  if (true) {
    boundary !== void 0 && console.warn("The Popover boundary prop has been deprecated. If you want to constrain the popper to a specific element use the appendTo prop instead.");
    tippyProps !== void 0 && console.warn("The Popover tippyProps prop has been deprecated and is no longer used.");
  }
  const uniqueId = id || getUniqueId();
  const triggerManually = isVisible !== null;
  const [visible, setVisible] = React52.useState(false);
  const [opacity, setOpacity] = React52.useState(0);
  const [focusTrapActive, setFocusTrapActive] = React52.useState(Boolean(propWithFocusTrap));
  const transitionTimerRef = React52.useRef(null);
  const showTimerRef = React52.useRef(null);
  const hideTimerRef = React52.useRef(null);
  React52.useEffect(() => {
    onMount();
  }, []);
  React52.useEffect(() => {
    if (triggerManually) {
      if (isVisible) {
        show();
      } else {
        hide2();
      }
    }
  }, [isVisible, triggerManually]);
  const show = (withFocusTrap) => {
    onShow();
    if (transitionTimerRef.current) {
      clearTimeout(transitionTimerRef.current);
    }
    if (hideTimerRef.current) {
      clearTimeout(hideTimerRef.current);
    }
    showTimerRef.current = setTimeout(() => {
      setVisible(true);
      setOpacity(1);
      propWithFocusTrap !== false && withFocusTrap && setFocusTrapActive(true);
      onShown();
    }, 0);
  };
  const hide2 = () => {
    onHide();
    if (showTimerRef.current) {
      clearTimeout(showTimerRef.current);
    }
    hideTimerRef.current = setTimeout(() => {
      setVisible(false);
      setOpacity(0);
      setFocusTrapActive(false);
      transitionTimerRef.current = setTimeout(() => {
        onHidden();
      }, animationDuration);
    }, 0);
  };
  const positionModifiers = {
    top: popover_default.modifiers.top,
    bottom: popover_default.modifiers.bottom,
    left: popover_default.modifiers.left,
    right: popover_default.modifiers.right,
    "top-start": popover_default.modifiers.topLeft,
    "top-end": popover_default.modifiers.topRight,
    "bottom-start": popover_default.modifiers.bottomLeft,
    "bottom-end": popover_default.modifiers.bottomRight,
    "left-start": popover_default.modifiers.leftTop,
    "left-end": popover_default.modifiers.leftBottom,
    "right-start": popover_default.modifiers.rightTop,
    "right-end": popover_default.modifiers.rightBottom
  };
  const hasCustomMinWidth = minWidth !== c_popover_MinWidth_default.value;
  const hasCustomMaxWidth = maxWidth !== c_popover_MaxWidth_default.value;
  const onDocumentKeyDown = (event) => {
    if (event.key === KeyTypes.Escape && visible) {
      if (triggerManually) {
        shouldClose(null, hide2, event);
      } else {
        hide2();
      }
    }
  };
  const onDocumentClick = (event, triggerElement, popperElement) => {
    if (hideOnOutsideClick && visible) {
      const isChild = popperElement && popperElement.contains(event.target);
      if (isChild) {
        return;
      }
      if (triggerManually) {
        shouldClose(null, hide2, event);
      } else {
        hide2();
      }
    }
  };
  const onTriggerClick = (event) => {
    if (triggerManually) {
      if (visible) {
        shouldClose(null, hide2, event);
      } else {
        shouldOpen(show, event);
      }
    } else {
      if (visible) {
        hide2();
      } else {
        show(true);
      }
    }
  };
  const onContentMouseDown = () => {
    if (focusTrapActive) {
      setFocusTrapActive(false);
    }
  };
  const closePopover = (event) => {
    event.stopPropagation();
    if (triggerManually) {
      shouldClose(null, hide2, event);
    } else {
      hide2();
    }
  };
  const content = React52.createElement(
    FocusTrap,
    Object.assign({ active: focusTrapActive, focusTrapOptions: {
      returnFocusOnDeactivate: true,
      clickOutsideDeactivates: true,
      tabbableOptions: { displayCheck: "none" },
      fallbackFocus: () => {
        let node = null;
        if (document && document.activeElement) {
          node = document.activeElement;
        }
        return node;
      }
    }, preventScrollOnDeactivate: true, className: css(popover_default.popover, alertSeverityVariant && alertStyle[alertSeverityVariant], hasNoPadding && popover_default.modifiers.noPadding, hasAutoWidth && popover_default.modifiers.widthAuto, className), role: "dialog", "aria-modal": "true", "aria-label": headerContent ? void 0 : ariaLabel, "aria-labelledby": headerContent ? `popover-${uniqueId}-header` : void 0, "aria-describedby": `popover-${uniqueId}-body`, onMouseDown: onContentMouseDown, style: {
      minWidth: hasCustomMinWidth ? minWidth : null,
      maxWidth: hasCustomMaxWidth ? maxWidth : null,
      opacity,
      transition: getOpacityTransition(animationDuration)
    } }, rest),
    React52.createElement(PopoverArrow, null),
    React52.createElement(
      PopoverContent,
      null,
      showClose && React52.createElement(PopoverCloseButton, { onClose: closePopover, "aria-label": closeBtnAriaLabel }),
      headerContent && React52.createElement(PopoverHeader, { id: `popover-${uniqueId}-header`, icon: headerIcon, alertSeverityVariant, alertSeverityScreenReaderText: alertSeverityScreenReaderText || `${alertSeverityVariant} alert:`, titleHeadingLevel: headerComponent }, typeof headerContent === "function" ? headerContent(hide2) : headerContent),
      React52.createElement(PopoverBody, { id: `popover-${uniqueId}-body` }, typeof bodyContent === "function" ? bodyContent(hide2) : bodyContent),
      footerContent && React52.createElement(PopoverFooter, { id: `popover-${uniqueId}-footer` }, typeof footerContent === "function" ? footerContent(hide2) : footerContent)
    )
  );
  return React52.createElement(
    PopoverContext.Provider,
    { value: { headerComponent } },
    React52.createElement(Popper, { trigger: children, reference: reference2, popper: content, popperMatchesTriggerWidth: false, appendTo, isVisible: visible, positionModifiers, distance, placement: position, onTriggerClick, onDocumentClick, onDocumentKeyDown, enableFlip, zIndex, flipBehavior, removeFindDomNode })
  );
};
Popover.displayName = "Popover";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/EmptyState/EmptyState.js
var React53 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/EmptyState/empty-state.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/components/EmptyState/empty-state.css";
var empty_state_default = {
  "button": "pf-c-button",
  "emptyState": "pf-c-empty-state",
  "emptyStateBody": "pf-c-empty-state__body",
  "emptyStateContent": "pf-c-empty-state__content",
  "emptyStateIcon": "pf-c-empty-state__icon",
  "emptyStatePrimary": "pf-c-empty-state__primary",
  "emptyStateSecondary": "pf-c-empty-state__secondary",
  "modifiers": {
    "xs": "pf-m-xs",
    "sm": "pf-m-sm",
    "lg": "pf-m-lg",
    "xl": "pf-m-xl",
    "fullHeight": "pf-m-full-height",
    "primary": "pf-m-primary",
    "overpassFont": "pf-m-overpass-font"
  },
  "title": "pf-c-title"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/EmptyState/EmptyState.js
var EmptyStateVariant;
(function(EmptyStateVariant2) {
  EmptyStateVariant2["xs"] = "xs";
  EmptyStateVariant2["small"] = "small";
  EmptyStateVariant2["large"] = "large";
  EmptyStateVariant2["xl"] = "xl";
  EmptyStateVariant2["full"] = "full";
})(EmptyStateVariant || (EmptyStateVariant = {}));
var EmptyState = (_a) => {
  var { children, className = "", variant = EmptyStateVariant.full, isFullHeight } = _a, props = __rest(_a, ["children", "className", "variant", "isFullHeight"]);
  return React53.createElement(
    "div",
    Object.assign({ className: css(empty_state_default.emptyState, variant === "xs" && empty_state_default.modifiers.xs, variant === "small" && empty_state_default.modifiers.sm, variant === "large" && empty_state_default.modifiers.lg, variant === "xl" && empty_state_default.modifiers.xl, isFullHeight && empty_state_default.modifiers.fullHeight, className) }, props),
    React53.createElement("div", { className: css(empty_state_default.emptyStateContent) }, children)
  );
};
EmptyState.displayName = "EmptyState";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/EmptyState/EmptyStateBody.js
var React54 = __toESM(require_react());
var EmptyStateBody = (_a) => {
  var { children, className = "" } = _a, props = __rest(_a, ["children", "className"]);
  return React54.createElement("div", Object.assign({ className: css(empty_state_default.emptyStateBody, className) }, props), children);
};
EmptyStateBody.displayName = "EmptyStateBody";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/EmptyState/EmptyStateIcon.js
var React55 = __toESM(require_react());
var EmptyStateIcon = (_a) => {
  var { className = "", icon: IconComponent, component: AnyComponent, variant = "icon" } = _a, props = __rest(_a, ["className", "icon", "component", "variant"]);
  const classNames = css(empty_state_default.emptyStateIcon, className);
  return variant === "icon" ? React55.createElement(IconComponent, Object.assign({ className: classNames }, props, { "aria-hidden": "true" })) : React55.createElement(
    "div",
    { className: classNames },
    React55.createElement(AnyComponent, null)
  );
};
EmptyStateIcon.displayName = "EmptyStateIcon";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/EmptyState/EmptyStateSecondaryActions.js
var React56 = __toESM(require_react());
var EmptyStateSecondaryActions = (_a) => {
  var { children = null, className = "" } = _a, props = __rest(_a, ["children", "className"]);
  return React56.createElement("div", Object.assign({ className: css(empty_state_default.emptyStateSecondary, className) }, props), children);
};
EmptyStateSecondaryActions.displayName = "EmptyStateSecondaryActions";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/components/EmptyState/EmptyStatePrimary.js
var React57 = __toESM(require_react());
var EmptyStatePrimary = (_a) => {
  var { children, className = "" } = _a, props = __rest(_a, ["children", "className"]);
  return React57.createElement("div", Object.assign({ className: css(empty_state_default.emptyStatePrimary, className) }, props), children);
};
EmptyStatePrimary.displayName = "EmptyStatePrimary";

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/layouts/Bullseye/Bullseye.js
var React58 = __toESM(require_react());

// ../../node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/layouts/Bullseye/bullseye.mjs
import "/Users/aleksejstarodubcev/Downloads/keycloak-main/js/node_modules/.pnpm/@patternfly+react-styles@4.92.8/node_modules/@patternfly/react-styles/css/layouts/Bullseye/bullseye.css";
var bullseye_default = {
  "bullseye": "pf-l-bullseye"
};

// ../../node_modules/.pnpm/@patternfly+react-core@4.278.0_react-dom@18.2.0_react@18.2.0/node_modules/@patternfly/react-core/dist/esm/layouts/Bullseye/Bullseye.js
var Bullseye = (_a) => {
  var { children = null, className = "", component = "div" } = _a, props = __rest(_a, ["children", "className", "component"]);
  const Component19 = component;
  return React58.createElement(Component19, Object.assign({ className: css(bullseye_default.bullseye, className) }, props), children);
};
Bullseye.displayName = "Bullseye";

export {
  global_breakpoint_md_default,
  global_breakpoint_lg_default,
  global_breakpoint_xl_default,
  global_breakpoint_2xl_default,
  KEY_CODES,
  SIDE,
  KEYHANDLER_DIRECTION,
  ValidatedOptions,
  KeyTypes,
  globalWidthBreakpoints,
  globalHeightBreakpoints,
  FocusTrap,
  GenerateId,
  ASTERISK,
  getOUIAProps,
  useOUIAProps,
  useOUIAId,
  getDefaultOUIAId,
  capitalize,
  getUniqueId,
  debounce,
  isElementInView,
  sideElementIsOutOfView,
  fillTemplate,
  keyHandler,
  findTabbableElements,
  getNextIndex,
  pluralize,
  setBreakpointCssVars,
  formatBreakpointMods,
  getVerticalBreakpoint,
  getBreakpoint,
  toCamel,
  canUseDOM,
  getTextWidth,
  innerDimensions,
  trimLeft,
  preventedEvents,
  useIsomorphicLayoutEffect,
  getOpacityTransition,
  Popper,
  handleArrows,
  setTabIndex,
  KeyboardHandler,
  getResizeObserver,
  useInterval,
  isValidDate,
  bullseye_default,
  TitleSizes,
  Title,
  button_default,
  spinnerSize,
  Spinner,
  Badge,
  ButtonVariant,
  ButtonType,
  Button,
  TooltipPosition,
  Tooltip,
  form_control_default,
  DropdownPosition,
  DropdownDirection,
  DropdownContext,
  DropdownArrowContext,
  DropdownMenu,
  DropdownWithContext,
  Dropdown,
  DropdownGroup,
  DropdownItem,
  DividerVariant,
  Divider,
  DropdownSeparator,
  BadgeToggle,
  KebabToggle,
  DropdownToggle,
  DropdownToggleCheckbox,
  DropdownToggleAction,
  ApplicationLauncherSeparator,
  createRenderableFavorites,
  extendItemsWithFavorite,
  TextInputTypes,
  TextInputReadOnlyVariant,
  TextInputBase,
  TextInput,
  form_default,
  check_default,
  SelectContext,
  SelectProvider,
  SelectConsumer,
  SelectVariant,
  SelectPosition,
  SelectDirection,
  SelectFooterTabbableItems,
  SelectOption,
  SelectGroup,
  Chip,
  ChipGroup,
  Select,
  Checkbox,
  PopoverPosition,
  Popover,
  EmptyStateVariant,
  EmptyState,
  EmptyStateBody,
  EmptyStateIcon,
  EmptyStateSecondaryActions,
  EmptyStatePrimary,
  Bullseye
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 5.3.3
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 6.9.2
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=chunk-NPANE4JW.js.map
